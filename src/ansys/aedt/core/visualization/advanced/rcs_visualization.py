# -*- coding: utf-8 -*-
#
# Copyright (C) 2021 - 2024 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json
import math

# import math
import os

from ansys.aedt.core.aedt_logger import pyaedt_logger as logger
from ansys.aedt.core.application.variables import decompose_variable_value
from ansys.aedt.core.generic.constants import AEDT_UNITS
from ansys.aedt.core.generic.constants import unit_converter
from ansys.aedt.core.generic.general_methods import conversion_function
from ansys.aedt.core.generic.general_methods import open_file
from ansys.aedt.core.generic.general_methods import pyaedt_function_handler
from ansys.aedt.core.visualization.plot.matplotlib import plot_2d_chart
from ansys.aedt.core.visualization.plot.matplotlib import plot_polar_chart
import pandas as pd

np = None
pv = None

try:
    import numpy as np
except ImportError:  # pragma: no cover
    np = None
try:
    import pyvista as pv
except ImportError:  # pragma: no cover
    pv = None


class MonostaticRCSData(object):
    """Provides monostatic radar cross-section (RCS) data.

    Read monostatic RCS metadata in a JSON file generated by :func:`MonostaticRCSExporter` and return the
    Python interface to plot and analyze the RCS data.

    Parameters
    ----------
    input_file : str
        Metadata information in a JSON file.

    Examples
    --------
    >>> from ansys.aedt.core import Hfss
    >>> from ansys.aedt.core.generic.rcs_visualization import MonostaticRCSData
    >>> app = Hfss(version="2023.2", design="Antenna")
    >>> data = app.get_rcs_data()
    >>> metadata_file = data.metadata_file
    >>> app.release_desktop()
    >>> rcs_data = MonostaticRCSData(input_file=metadata_file)
    """

    def __init__(self, input_file):

        # Public
        self.output_dir = os.path.dirname(input_file)

        if not os.path.isfile(input_file):  # pragma: no cover
            raise Exception("JSON file does not exist.")

        # Private
        self.__logger = logger
        self.__input_file = input_file
        self.__raw_data = {}
        self.__frequency = None
        self.__freq_index = 0
        self.__model_units = "meter"
        self.__name = None

        self.__incident_wave_theta = None
        self.__incident_wave_phi = None
        self.__available_incident_wave_theta = None
        self.__available_incident_wave_phi = None

        self.__frequencies = []

        self.__model_info = {}
        self.__component_objects = None

        with open_file(input_file) as f:
            self.__metadata = json.load(f)

        if not self.metadata:  # pragma: no cover
            raise Exception("Metadata could not be loaded..")

        self.__frequency_units = self.metadata["frequency_units"]

        self.__monostatic_file = os.path.join(self.output_dir, self.metadata["monostatic_file"])

        self.__data_conversion_function = "dB10"
        self.__window = "Flat"
        self.__window_size = 1024

        if not os.path.isfile(self.__monostatic_file):  # pragma: no cover
            raise Exception("Monostatic file invalid.")

        self.rcs_index_names = {
            "RCS": ["IWavePhi", "IWaveTheta"],
            "Range Profile": ["Range", "IWavePhi", "IWaveTheta"],
            "Waterfall": ["Range", "IWavePhi", "IWaveTheta"],
            "2D ISAR": ["Down-range", "Cross-range"],
            "3D ISAR": ["Down-range", "Cross-range1", "Cross-range2"],
        }
        self.rcs_column_names = ["data"]

        # Load farfield data
        is_rcs_loaded = self.__init_rcs()

        if not is_rcs_loaded:  # pragma: no cover
            raise Exception("RCS information can not be loaded.")

        # Update active frequency if passed in the initialization
        self.frequency = self.frequencies[0]

    @property
    def metadata(self):
        """Antenna metadata."""
        return self.__metadata

    @property
    def name(self):
        """Antenna metadata."""
        self.__name = self.__raw_data.columns[0]
        return self.__name

    @property
    def input_file(self):
        """Input file."""
        return self.__input_file

    @property
    def frequency_units(self):
        """Frequency units."""
        return self.__frequency_units

    @property
    def frequencies(self):
        """Available frequencies."""
        if "Freq" in self.__raw_data.index.names:
            frequencies = np.unique(np.array(self.__raw_data.index.get_level_values("Freq")))
            self.__frequencies = frequencies.tolist()
        return self.__frequencies

    @property
    def available_incident_wave_theta(self):
        """Available incident wave Theta."""
        if "IWaveTheta" in self.__raw_data.index.names:
            self.__incident_wave_theta = np.unique(np.array(self.__raw_data.index.get_level_values("IWaveTheta")))
        return self.__incident_wave_theta

    @property
    def incident_wave_theta(self):
        """Active incident wave Theta."""
        if not self.__incident_wave_theta:
            self.__incident_wave_theta = self.available_incident_wave_theta[0]
        return self.__incident_wave_theta

    @incident_wave_theta.setter
    def incident_wave_theta(self, val):
        """Active incident wave Theta."""
        if val in self.available_incident_wave_theta:
            self.__incident_wave_theta = val
        else:
            self.__logger.error("Value not available.")

    @property
    def available_incident_wave_phi(self):
        """Available incident wave Phi."""
        if "IWavePhi" in self.__raw_data.index.names:
            self.__incident_wave_phi = np.unique(np.array(self.__raw_data.index.get_level_values("IWavePhi")))
        return self.__incident_wave_phi

    @property
    def incident_wave_phi(self):
        """Active incident wave Phi."""
        if not self.__incident_wave_phi:
            self.__incident_wave_phi = self.available_incident_wave_phi[0]
        return self.__incident_wave_phi

    @incident_wave_phi.setter
    def incident_wave_phi(self, val):
        """Active incident wave Phi."""
        if val in self.available_incident_wave_phi:
            self.__incident_wave_phi = val
        else:
            self.__logger.error("Value not available.")

    @property
    def frequency(self):
        """Active frequency."""
        return self.__frequency

    @frequency.setter
    def frequency(self, val):
        if isinstance(val, str):
            frequency, units = decompose_variable_value(val)
            unit_converter(frequency, "Freq", units, "Hz")
            val = frequency
        if val in self.frequencies:
            self.__frequency = val
            self.__freq_index = self.frequencies.index(val)
        else:  # pragma: no cover
            self.__logger.error("Frequency not available.")

    @property
    def data_conversion_function(self):
        """RCS data conversion function.
        The available functions are:

        - `"dB10"`: Converts the data to decibels using base 10 logarithm.
        - `"dB20"`: Converts the data to decibels using base 20 logarithm.
        - `"abs"`: Computes the absolute value of the data.
        - `"real"`: Computes the real part of the data.
        - `"imag"`: Computes the imaginary part of the data.
        - `"norm"`: Normalizes the data to have values between 0 and 1.
        - `"ang"`: Computes the phase angle of the data in radians.
        - `"ang_deg"`: Computes the phase angle of the data in degrees.
        """
        return self.__data_conversion_function

    @data_conversion_function.setter
    def data_conversion_function(self, val):
        available_functions = ["dB10", "dB20", "abs", "real", "imag", "norm", "ang", "ang_deg"]
        if val in available_functions:
            self.__data_conversion_function = val

    @property
    def window(self):
        """Window function.
        The available functions are: Options are ``"Flat"``, ``"Hamming``", and ``"Hann"``.
        """
        return self.__window

    @window.setter
    def window(self, val):
        available_functions = ["Flat", "Hamming", "Hann"]
        if val in available_functions:
            self.__window = val

    @property
    def window_size(self):
        """Window size."""
        return self.__window_size

    @window_size.setter
    def window_size(self, val):
        self.__window_size = val

    @property
    def rcs(self):
        """RCS data."""
        data = self.__raw_data.xs(key=self.frequency, level="Freq")
        data_converted = conversion_function(data[self.name], self.data_conversion_function)
        return data_converted

    @property
    def range_profile(self):
        """Range profile."""
        # Data by frequency
        data = self.__raw_data[self.name]
        data_freq = data.loc[:, self.incident_wave_phi, self.incident_wave_theta]

        # Take needed properties
        size = self.window_size
        nfreq = len(self.frequencies)

        # Compute window
        win_range, _ = self.window_function(self.window, nfreq)
        windowed_data = data_freq * win_range

        # Peroform FFT
        sf_upsample = self.window_size / nfreq
        windowed_data = np.fft.fftshift(sf_upsample * np.fft.ifft(windowed_data.to_numpy(), n=size))

        # Convert data to conversion function
        windowed_data_converted = conversion_function(windowed_data, self.data_conversion_function)

        df = (
            unit_converter((self.frequencies[1] - self.frequencies[0]), "Frequency", self.frequency_units, "Hz") * 1.0e9
        )  # TODO make this automatic!
        pd_t = 1.0 / df
        dt = pd_t / size
        c0 = 299792458
        range_norm = dt * np.linspace(start=-0.5 * size, stop=0.5 * size - 1, num=size) / 2 * c0

        phis = np.ones(range_norm.size) * self.incident_wave_phi
        thetas = np.ones(range_norm.size) * self.incident_wave_theta
        indexes = zip(range_norm, phis, thetas)

        index_names = self.rcs_index_names["Range Profile"]

        return self.__get_new_dataframe(values=windowed_data_converted, indexes=indexes, index_names=index_names)

    @staticmethod
    def window_function(window="Flat", size=512):
        """Window function.

        Parameters
        ----------
        window : str, optional.
            Window function. The default is ``"Flat"``. Options are ``"Flat"``, ``"Hamming``", and ``"Hann"``.
        size : int, optional
            Window size. The default is ``512``.

        Returns
        -------
        tuple
            Data windowed and data sum.
        """
        if window == "Hann":
            win = np.hanning(size)
        elif window == "Hamming":
            win = np.hamming(size)
        else:
            win = np.ones(size)
        win_sum = np.sum(win)
        win *= size / win_sum
        return win, win_sum

    @pyaedt_function_handler()
    def plot_rcs(
        self,
        primary_sweep="IWavePhi",
        secondary_sweep_value=None,
        title="Monostatic RCS",
        output_file=None,
        show=True,
        is_polar=False,
        show_legend=True,
    ):
        """Create a 2D plot of the monostatic RCS.

        Parameters
        ----------
        primary_sweep : str, optional.
            X-axis variable. The default is ``"IWavePhi"``. Options are ``"IWavePhi"`` and ``"IWaveTheta"``.
        secondary_sweep_value : float, list, string, optional
            List of cuts on the secondary sweep to plot. The default is ``0``. Options are
            `"all"`, a single value float, or a list of float values.
        title : str, optional
            Plot title. The default is ``"RectangularPlot"``.
        output_file : str, optional
            Full path for the image file. The default is ``None``, in which case an image in not exported.
        show : bool, optional
            Whether to show the plot. The default is ``True``.
            If ``False``, the Matplotlib instance of the plot is shown.
        is_polar : bool, optional
            Whether this plot is a polar plot. The default is ``True``.
        show_legend : bool, optional
            Whether to display the legend or not. The default is ``True``.

        Returns
        -------
        :class:`matplotlib.pyplot.Figure`
            Matplotlib figure object.
            If ``show=True``, a Matplotlib figure instance of the plot is returned.
            If ``show=False``, the plotted curve is returned.

        Examples
        --------
        >>> import pyaedt
        >>> app = pyaedt.Hfss(version="2023.2", design="Antenna")
        >>> setup_name = "Setup1 : LastAdaptive"
        >>> frequencies = [77e9]
        >>> sphere = "3D"
        >>> data = app.get_antenna_data(frequencies,setup_name,sphere)
        >>> data.plot_cut(theta=20)
        """

        data_freq = self.rcs

        curves = []
        all_secondary_sweep_value = secondary_sweep_value
        if primary_sweep.lower() == "iwavephi":
            x_key = "IWavePhi"
            y_key = "IWaveTheta"
            x = self.available_incident_wave_phi
            if isinstance(secondary_sweep_value, str) and secondary_sweep_value == "all":
                all_secondary_sweep_value = self.available_incident_wave_theta
            elif secondary_sweep_value is None:
                all_secondary_sweep_value = self.incident_wave_theta

        else:
            x_key = "IWaveTheta"
            y_key = "IWavePhi"
            x = self.available_incident_wave_theta
            if isinstance(secondary_sweep_value, str) and secondary_sweep_value == "all":
                all_secondary_sweep_value = self.available_incident_wave_phi
            elif secondary_sweep_value is None:
                all_secondary_sweep_value = self.incident_wave_phi

        if not isinstance(all_secondary_sweep_value, np.ndarray) and not isinstance(all_secondary_sweep_value, list):
            all_secondary_sweep_value = [all_secondary_sweep_value]

        if is_polar:
            x = [i * 2 * math.pi / 360 for i in x]
        if all_secondary_sweep_value is not None:
            for el in all_secondary_sweep_value:
                data = data_freq.xs(key=el, level=y_key)
                y = data.values
                if not isinstance(y, np.ndarray):  # pragma: no cover
                    raise Exception("Format of quantity is wrong.")
                curves.append([x, y, "{}={}".format(y_key, el)])

        if is_polar:
            return plot_polar_chart(
                curves,
                xlabel=x_key,
                ylabel="RCS",
                title=title,
                snapshot_path=output_file,
                show_legend=show_legend,
                show=show,
            )
        else:
            return plot_2d_chart(
                curves,
                xlabel=x_key,
                ylabel="RCS",
                title=title,
                snapshot_path=output_file,
                show_legend=show_legend,
                show=show,
            )

    @pyaedt_function_handler()
    def plot_range_profile(
        self,
        title="Range profile",
        output_file=None,
        show=True,
        show_legend=True,
    ):
        """Create a 2D plot of the monostatic RCS.

        Parameters
        ----------
        primary_sweep : str, optional.
            X-axis variable. The default is ``"IWavePhi"``. Options are ``"IWavePhi"`` and ``"IWaveTheta"``.
        secondary_sweep_value : float, list, string, optional
            List of cuts on the secondary sweep to plot. The default is ``0``. Options are
            `"all"`, a single value float, or a list of float values.
        title : str, optional
            Plot title. The default is ``"RectangularPlot"``.
        output_file : str, optional
            Full path for the image file. The default is ``None``, in which case an image in not exported.
        show : bool, optional
            Whether to show the plot. The default is ``True``.
            If ``False``, the Matplotlib instance of the plot is shown.
        is_polar : bool, optional
            Whether this plot is a polar plot. The default is ``True``.
        show_legend : bool, optional
            Whether to display the legend or not. The default is ``True``.

        Returns
        -------
        :class:`matplotlib.pyplot.Figure`
            Matplotlib figure object.
            If ``show=True``, a Matplotlib figure instance of the plot is returned.
            If ``show=False``, the plotted curve is returned.

        Examples
        --------
        >>> import pyaedt
        >>> app = pyaedt.Hfss(version="2023.2", design="Antenna")
        >>> setup_name = "Setup1 : LastAdaptive"
        >>> frequencies = [77e9]
        >>> sphere = "3D"
        >>> data = app.get_antenna_data(frequencies,setup_name,sphere)
        >>> data.plot_cut(theta=20)
        """

        data_range_profile = self.range_profile

        ranges = np.unique(data_range_profile.index.get_level_values("Range"))
        phis = np.unique(data_range_profile.index.get_level_values("IWavePhi"))
        thetas = np.unique(data_range_profile.index.get_level_values("IWaveTheta"))

        curves = []
        n_range = len(ranges)
        n_phi = len(phis)
        n_theta = len(thetas)
        values = data_range_profile["data"].to_numpy()
        values = values.reshape((n_range, n_phi, n_theta), order="F")
        y = values[:, 0, 0]
        legend = f"Phi={np.round(phis[0], 3)} Theta={np.round(thetas[0], 3)}"
        curves.append([ranges.tolist(), y.tolist(), legend])

        return plot_2d_chart(
            curves,
            xlabel="Range (m)",
            ylabel=f"Range Profile ({self.data_conversion_function})",
            title=title,
            snapshot_path=output_file,
            show_legend=show_legend,
            show=show,
        )

    @pyaedt_function_handler()
    def __init_rcs(self):
        """Load monostatic radar cross-section data.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """

        file_extension = os.path.splitext(self.__monostatic_file)[1]
        if file_extension == "h5":
            try:
                self.__raw_data = df.read_hdf(self.__monostatic_file, key="df", mode="w", format="table")
            except ImportError as e:  # pragma: no cover
                self.__app.logger.error(f"PyTables is not installed: {e}")
                return False
        else:
            self.__raw_data = pd.read_pickle(self.__monostatic_file)
        return True

    @pyaedt_function_handler()
    def __get_geometry(self, off_screen=False):
        """Get 3D meshes."""
        model_info = self.metadata["model_info"]
        obj_meshes = []
        if self.__is_array:
            non_array_geometry = model_info.copy()
            components_info = self.__component_objects
            array_dimension = self.__array_dimension
            first_value = next(iter(model_info.values()))
            sf = AEDT_UNITS["Length"][first_value[3]]
            self.__model_units = first_value[3]
            cell_info = self.__cell_position

            for cell_row in cell_info:
                for cell_col in cell_row:
                    # Initialize an empty mesh for this component
                    model_pv = ModelPlotter()
                    model_pv.off_screen = off_screen
                    component_name = cell_col[0]
                    component_info = components_info[component_name]
                    rotation = cell_col[2]
                    for component_obj in component_info[1:]:
                        if component_obj in model_info:
                            if component_obj in non_array_geometry:
                                del non_array_geometry[component_obj]

                            cad_path = os.path.join(self.output_dir, model_info[component_obj][0])
                            if os.path.exists(cad_path):
                                model_pv.add_object(
                                    cad_path,
                                    model_info[component_obj][1],
                                    model_info[component_obj][2],
                                    model_info[component_obj][3],
                                )

                    model_pv.generate_geometry_mesh()
                    comp_meshes = []
                    row, col = cell_col[3]

                    # Perpendicular lattice vector
                    if self.__lattice_vector[0] != 0:
                        pos_x = (row - 1) * array_dimension[2] - array_dimension[0] / 2 + array_dimension[2] / 2
                        pos_y = (col - 1) * array_dimension[3] - array_dimension[1] / 2 + array_dimension[3] / 2
                    else:
                        pos_y = (row - 1) * array_dimension[2] - array_dimension[0] / 2 + array_dimension[2] / 2
                        pos_x = (col - 1) * array_dimension[3] - array_dimension[1] / 2 + array_dimension[3] / 2

                    for obj in model_pv.objects:
                        mesh = obj._cached_polydata
                        translated_mesh = mesh.copy()
                        color_cad = [i / 255 for i in obj.color]

                        translated_mesh.translate(
                            [-component_info[0][0] / sf, -component_info[0][1] / sf, -component_info[0][2] / sf],
                            inplace=True,
                        )

                        if rotation != 0:
                            translated_mesh.rotate_z(rotation, inplace=True)

                        # Translate the mesh to its position
                        translated_mesh.translate([pos_x / sf, pos_y / sf, component_info[0][2] / sf], inplace=True)

                        comp_meshes.append([translated_mesh, color_cad, obj.opacity])

                    obj_meshes.append(comp_meshes)
                    model_pv.close()

            obj_meshes = [item for sublist in obj_meshes for item in sublist]
        else:
            non_array_geometry = model_info

        if non_array_geometry:  # pragma: no cover
            model_pv = ModelPlotter()
            first_value = next(iter(non_array_geometry.values()))
            sf = AEDT_UNITS["Length"][first_value[3]]
            self.__model_units = first_value[3]
            model_pv.off_screen = off_screen
            for object_in in non_array_geometry.values():
                cad_path = os.path.join(self.output_dir, object_in[0])
                if os.path.exists(cad_path):
                    model_pv.add_object(
                        cad_path,
                        object_in[1],
                        object_in[2],
                        object_in[3],
                    )
                else:
                    self.logger.warning(f"{cad_path} does not exist.")
                    return False
            self.__model_units = first_value[3]
            model_pv.generate_geometry_mesh()
            i = 0
            for obj in model_pv.objects:
                mesh = obj._cached_polydata
                translated_mesh = mesh.copy()
                color_cad = [i / 255 for i in obj.color]

                if len(obj_meshes) > i:
                    obj_meshes[i][0] += translated_mesh
                else:
                    obj_meshes.append([translated_mesh, color_cad, obj.opacity])
                i += 1
            model_pv.close()

        return obj_meshes

    @pyaedt_function_handler()
    def __get_new_dataframe(self, values=None, index_names=None, indexes=None):
        """Create new RCS DataFrame."""
        if indexes is None:
            indexes = []
        if index_names is None:
            index_names = []
        my_index = pd.MultiIndex.from_tuples(indexes, names=index_names)
        if values is None:
            df = pd.DataFrame(index=my_index, columns=self.rcs_column_names)
        else:
            df = pd.DataFrame(values, index=my_index, columns=self.rcs_column_names)
        return df
