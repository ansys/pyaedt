# -*- coding: utf-8 -*-
#
# Copyright (C) 2021 - 2024 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json
import math

# import math
import os

from ansys.aedt.core.aedt_logger import pyaedt_logger as logger
from ansys.aedt.core.application.variables import decompose_variable_value
from ansys.aedt.core.generic.constants import unit_converter
from ansys.aedt.core.generic.general_methods import conversion_function
from ansys.aedt.core.generic.general_methods import open_file
from ansys.aedt.core.generic.general_methods import pyaedt_function_handler
from ansys.aedt.core.visualization.plot.matplotlib import plot_2d_chart
from ansys.aedt.core.visualization.plot.matplotlib import plot_polar_chart
from ansys.aedt.core.visualization.plot.pyvista import ModelPlotter
from ansys.tools.visualization_interface import MeshObjectPlot
from ansys.tools.visualization_interface import Plotter
from ansys.tools.visualization_interface.backends.pyvista import PyVistaBackend
import pandas as pd

try:
    import numpy as np
except ImportError:  # pragma: no cover
    np = None
try:
    import pyvista as pv
except ImportError:  # pragma: no cover
    pv = None


class MonostaticRCSData(object):
    """Provides monostatic radar cross-section (RCS) data.

    Read monostatic RCS metadata in a JSON file generated by :func:`MonostaticRCSExporter` and return the
    Python interface to plot and analyze the RCS data.

    Parameters
    ----------
    input_file : str
        Metadata information in a JSON file.

    Examples
    --------
    >>> from ansys.aedt.core import Hfss
    >>> from ansys.aedt.core.generic.rcs_visualization import MonostaticRCSData
    >>> app = Hfss(version="2023.2", design="Antenna")
    >>> data = app.get_rcs_data()
    >>> metadata_file = data.metadata_file
    >>> app.release_desktop()
    >>> rcs_data = MonostaticRCSData(input_file=metadata_file)
    """

    def __init__(self, input_file):

        # Public
        self.output_dir = os.path.dirname(input_file)

        if not os.path.isfile(input_file):  # pragma: no cover
            raise Exception("JSON file does not exist.")

        # Private
        self.__logger = logger
        self.__input_file = input_file
        self.__raw_data = {}
        self.__frequency = None
        self.__freq_index = 0
        self.__model_units = "meter"
        self.__name = None

        self.__incident_wave_theta = None
        self.__incident_wave_phi = None
        self.__available_incident_wave_theta = None
        self.__available_incident_wave_phi = None

        self.__frequencies = []

        self.__model_info = {}
        self.__component_objects = None

        with open_file(input_file) as f:
            self.__metadata = json.load(f)

        if not self.metadata:  # pragma: no cover
            raise Exception("Metadata could not be loaded..")

        self.__frequency_units = self.metadata["frequency_units"]

        self.__monostatic_file = os.path.join(self.output_dir, self.metadata["monostatic_file"])

        self.__data_conversion_function = "dB10"
        self.__window = "Flat"
        self.__window_size = 1024

        if not os.path.isfile(self.__monostatic_file):  # pragma: no cover
            raise Exception("Monostatic file invalid.")

        self.rcs_index_names = {
            "RCS": ["IWavePhi", "IWaveTheta"],
            "Range Profile": ["Range", "IWavePhi", "IWaveTheta"],
            "Waterfall": ["Range", "IWavePhi", "IWaveTheta"],
            "2D ISAR": ["Down-range", "Cross-range"],
            "3D ISAR": ["Down-range", "Cross-range1", "Cross-range2"],
        }
        self.rcs_column_names = ["data"]

        # Load farfield data
        is_rcs_loaded = self.__init_rcs()

        if not is_rcs_loaded:  # pragma: no cover
            raise Exception("RCS information can not be loaded.")

        # Update active frequency if passed in the initialization
        self.frequency = self.frequencies[0]

    @property
    def raw_data(self):
        """Antenna data."""
        return self.__raw_data

    @property
    def metadata(self):
        """Antenna metadata."""
        return self.__metadata

    @property
    def name(self):
        """Antenna metadata."""
        self.__name = self.raw_data.columns[0]
        return self.__name

    @property
    def input_file(self):
        """Input file."""
        return self.__input_file

    @property
    def frequency_units(self):
        """Frequency units."""
        return self.__frequency_units

    @property
    def frequencies(self):
        """Available frequencies."""
        if "Freq" in self.raw_data.index.names:
            frequencies = np.unique(np.array(self.raw_data.index.get_level_values("Freq")))
            self.__frequencies = frequencies.tolist()
        return self.__frequencies

    @property
    def available_incident_wave_theta(self):
        """Available incident wave Theta."""
        if "IWaveTheta" in self.raw_data.index.names:
            self.__available_incident_wave_theta = np.unique(
                np.array(self.raw_data.index.get_level_values("IWaveTheta"))
            )
        return self.__available_incident_wave_theta

    @property
    def incident_wave_theta(self):
        """Active incident wave Theta."""
        if self.__incident_wave_theta is None:
            self.__incident_wave_theta = self.available_incident_wave_theta[0]
        return self.__incident_wave_theta

    @incident_wave_theta.setter
    def incident_wave_theta(self, val):
        """Active incident wave Theta."""
        if val in self.available_incident_wave_theta:
            self.__incident_wave_theta = val
        else:
            self.__logger.error("Value not available.")

    @property
    def available_incident_wave_phi(self):
        """Available incident wave Phi."""
        if "IWavePhi" in self.raw_data.index.names:
            self.__available_incident_wave_phi = np.unique(np.array(self.raw_data.index.get_level_values("IWavePhi")))
        return self.__available_incident_wave_phi

    @property
    def incident_wave_phi(self):
        """Active incident wave Phi."""
        if self.__incident_wave_phi is None:
            self.__incident_wave_phi = self.available_incident_wave_phi[0]
        return self.__incident_wave_phi

    @incident_wave_phi.setter
    def incident_wave_phi(self, val):
        """Active incident wave Phi."""
        if val in self.available_incident_wave_phi:
            self.__incident_wave_phi = val
        else:
            self.__logger.error("Value not available.")

    @property
    def frequency(self):
        """Active frequency."""
        return self.__frequency

    @frequency.setter
    def frequency(self, val):
        if isinstance(val, str):
            frequency, units = decompose_variable_value(val)
            unit_converter(frequency, "Freq", units, "Hz")
            val = frequency
        if val in self.frequencies:
            self.__frequency = val
            self.__freq_index = self.frequencies.index(val)
        else:  # pragma: no cover
            self.__logger.error("Frequency not available.")

    @property
    def data_conversion_function(self):
        """RCS data conversion function.
        The available functions are:

        - `"dB10"`: Converts the data to decibels using base 10 logarithm.
        - `"dB20"`: Converts the data to decibels using base 20 logarithm.
        - `"abs"`: Computes the absolute value of the data.
        - `"real"`: Computes the real part of the data.
        - `"imag"`: Computes the imaginary part of the data.
        - `"norm"`: Normalizes the data to have values between 0 and 1.
        - `"ang"`: Computes the phase angle of the data in radians.
        - `"ang_deg"`: Computes the phase angle of the data in degrees.
        """
        return self.__data_conversion_function

    @data_conversion_function.setter
    def data_conversion_function(self, val):
        available_functions = ["dB10", "dB20", "abs", "real", "imag", "norm", "ang", "ang_deg"]
        if val in available_functions:
            self.__data_conversion_function = val

    @property
    def window(self):
        """Window function.
        The available functions are: Options are ``"Flat"``, ``"Hamming``", and ``"Hann"``.
        """
        return self.__window

    @window.setter
    def window(self, val):
        available_functions = ["Flat", "Hamming", "Hann"]
        if val in available_functions:
            self.__window = val

    @property
    def window_size(self):
        """Window size."""
        return self.__window_size

    @window_size.setter
    def window_size(self, val):
        self.__window_size = val

    @property
    def rcs(self):
        """RCS data."""
        data = self.raw_data.xs(key=self.frequency, level="Freq")
        data_converted = conversion_function(data[self.name], self.data_conversion_function)
        return data_converted

    @property
    def range_profile(self):
        """Range profile."""
        # Data by frequency
        data = self.data[self.name]
        data_freq = data.loc[:, self.incident_wave_phi, self.incident_wave_theta]

        # Take needed properties
        size = self.window_size
        nfreq = len(self.frequencies)

        # Compute window
        win_range, _ = self.window_function(self.window, nfreq)
        windowed_data = data_freq * win_range

        # Perform FFT
        sf_upsample = self.window_size / nfreq
        windowed_data = np.fft.fftshift(sf_upsample * np.fft.ifft(windowed_data.to_numpy(), n=size))

        # Convert data to conversion function
        windowed_data_converted = conversion_function(windowed_data, self.data_conversion_function)

        df = unit_converter((self.frequencies[1] - self.frequencies[0]), "Freq", self.frequency_units, "Hz")
        pd_t = 1.0 / df
        dt = pd_t / size
        c0 = 299792458
        range_norm = dt * np.linspace(start=-0.5 * size, stop=0.5 * size - 1, num=size) / 2 * c0

        phis = np.ones(range_norm.size) * self.incident_wave_phi
        thetas = np.ones(range_norm.size) * self.incident_wave_theta
        indexes = zip(range_norm, phis, thetas)

        index_names = self.rcs_index_names["Range Profile"]

        return self.__get_new_dataframe(values=windowed_data_converted, indexes=indexes, index_names=index_names)

    @staticmethod
    def window_function(window="Flat", size=512):
        """Window function.

        Parameters
        ----------
        window : str, optional.
            Window function. The default is ``"Flat"``. Options are ``"Flat"``, ``"Hamming``", and ``"Hann"``.
        size : int, optional
            Window size. The default is ``512``.

        Returns
        -------
        tuple
            Data windowed and data sum.
        """
        if window == "Hann":
            win = np.hanning(size)
        elif window == "Hamming":
            win = np.hamming(size)
        else:
            win = np.ones(size)
        win_sum = np.sum(win)
        win *= size / win_sum
        return win, win_sum

    @pyaedt_function_handler()
    def __init_rcs(self):
        """Load monostatic radar cross-section data.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """

        file_extension = os.path.splitext(self.__monostatic_file)[1]
        if file_extension == "h5":
            try:
                self.__raw_data = df.read_hdf(self.__monostatic_file, key="df", mode="w", format="table")
            except ImportError as e:  # pragma: no cover
                self.__app.logger.error(f"PyTables is not installed: {e}")
                return False
        else:
            self.__raw_data = pd.read_pickle(self.__monostatic_file)
        return True

    @pyaedt_function_handler()
    def __get_new_dataframe(self, values=None, index_names=None, indexes=None):
        """Create new RCS DataFrame."""
        if indexes is None:
            indexes = []
        if index_names is None:
            index_names = []
        my_index = pd.MultiIndex.from_tuples(indexes, names=index_names)
        if values is None:
            df = pd.DataFrame(index=my_index, columns=self.rcs_column_names)
        else:
            df = pd.DataFrame(values, index=my_index, columns=self.rcs_column_names)
        return df


class MonostaticRCSPlotter(object):
    """Provides monostatic radar cross-section (RCS) plot functionalities.

    Parameters
    ----------
    rcs_data : :class:`ansys.aedt.core.generic.rcs_visualization.MonostaticRCSData`
        Monostatic RCS data object.

    Examples
    --------
    >>> from ansys.aedt.core import Hfss
    >>> from ansys.aedt.core.generic.rcs_visualization import MonostaticRCSData
    >>> from ansys.aedt.core.generic.rcs_visualization import MonostaticRCSPlotter
    >>> app = Hfss(version="2023.2", design="Antenna")
    >>> data = app.get_rcs_data()
    >>> metadata_file = data.metadata_file
    >>> app.release_desktop()
    >>> rcs_data = MonostaticRCSData(input_file=metadata_file)
    >>> rcs_plotter = MonostaticRCSPlotter(rcs_data)
    """

    def __init__(self, rcs_data):

        # Public
        self.modeler_window = None

        # Private
        self.__rcs_data = rcs_data
        self.__logger = logger
        self.__model_units = "meter"

        # Scene properties
        self.show_geometry = True
        self.__all_scene_actors = {"model": {}, "annotations": {}, "results": {}}
        self.__x_max, self.__x_min, self.__y_max, self.__y_min, self.__z_max, self.__z_min = 0, 0, 0, 0, 0, 0

        # Get geometries
        if "model_info" in self.rcs_data.metadata.keys():
            self.__model_info = self.rcs_data.metadata["model_info"]
            obj_meshes = self.__get_geometry()
            self.__all_scene_actors["model"] = obj_meshes

        # Get model extent
        self.__get_model_extent()

    @property
    def rcs_data(self):
        """RCS data object."""
        return self.__rcs_data

    @property
    def model_info(self):
        """Geometry information."""
        return self.__model_info

    @property
    def model_units(self):
        """Model units."""
        return self.__model_units

    @property
    def all_scene_actors(self):
        """All scene actors."""
        return self.__all_scene_actors

    @property
    def extents(self):
        """Geometry extents."""
        return [self.__x_min, self.__x_max, self.__y_min, self.__y_max, self.__z_min, self.__z_max]

    @property
    def center(self):
        """Geometry extents."""
        x_mid = (self.__x_max + self.__x_min) / 2
        z_mid = (self.__z_max + self.__z_min) / 2
        y_mid = (self.__y_max + self.__y_min) / 2
        return np.array([x_mid, y_mid, z_mid])

    @property
    def radius(self):
        """Geometry extents."""
        return max([abs(a) for a in (self.__x_min, self.__x_max, self.__y_min, self.__y_max)])

    @pyaedt_function_handler()
    def plot_range_profile(
        self,
        title="Range profile",
        output_file=None,
        show=True,
        show_legend=True,
    ):
        """Create a 2D plot of the range profile.

        Parameters
        ----------
        title : str, optional
            Plot title. The default is ``"RectangularPlot"``.
        output_file : str, optional
            Full path for the image file. The default is ``None``, in which case an image in not exported.
        show : bool, optional
            Whether to show the plot. The default is ``True``.
            If ``False``, the Matplotlib instance of the plot is shown.
        show_legend : bool, optional
            Whether to display the legend or not. The default is ``True``.

        Returns
        -------
        :class:`matplotlib.pyplot.Figure`
            Matplotlib figure object.
            If ``show=True``, a Matplotlib figure instance of the plot is returned.
            If ``show=False``, the plotted curve is returned.
        """

        data_range_profile = self.rcs_data.range_profile

        ranges = np.unique(data_range_profile.index.get_level_values("Range"))
        phis = np.unique(data_range_profile.index.get_level_values("IWavePhi"))
        thetas = np.unique(data_range_profile.index.get_level_values("IWaveTheta"))

        curves = []
        n_range = len(ranges)
        n_phi = len(phis)
        n_theta = len(thetas)
        values = data_range_profile["data"].to_numpy()
        values = values.reshape((n_range, n_phi, n_theta), order="F")
        y = values[:, 0, 0]
        legend = f"Phi={np.round(phis[0], 3)} Theta={np.round(thetas[0], 3)}"
        curves.append([ranges.tolist(), y.tolist(), legend])

        return plot_2d_chart(
            curves,
            xlabel="Range (m)",
            ylabel=f"Range Profile ({self.rcs_data.data_conversion_function})",
            title=title,
            snapshot_path=output_file,
            show_legend=show_legend,
            show=show,
        )

    @pyaedt_function_handler()
    def plot_rcs(
        self,
        primary_sweep="IWavePhi",
        secondary_sweep="IWaveTheta",
        secondary_sweep_value=None,
        title="Monostatic RCS",
        output_file=None,
        show=True,
        is_polar=False,
        show_legend=True,
    ):
        """Create a 2D plot of the monostatic RCS.

        Parameters
        ----------
        primary_sweep : str, optional.
            X-axis variable. The default is ``"IWavePhi"``. Options are ``"Freq"``, ``"IWavePhi"`` and ``"IWaveTheta"``.
        secondary_sweep : str, optional.
            X-axis variable. The default is ``"IWavePhi"``. Options are ``"Freq"``, ``"IWavePhi"`` and ``"IWaveTheta"``.
        secondary_sweep_value : float, list, string, optional
            List of cuts on the secondary sweep to plot. The default is ``0``. Options are
            `"all"`, a single value float, or a list of float values.
        title : str, optional
            Plot title. The default is ``"RectangularPlot"``.
        output_file : str, optional
            Full path for the image file. The default is ``None``, in which case an image in not exported.
        show : bool, optional
            Whether to show the plot. The default is ``True``.
            If ``False``, the Matplotlib instance of the plot is shown.
        is_polar : bool, optional
            Whether this plot is a polar plot. The default is ``True``.
        show_legend : bool, optional
            Whether to display the legend or not. The default is ``True``.

        Returns
        -------
        :class:`matplotlib.pyplot.Figure`
            Matplotlib figure object.
            If ``show=True``, a Matplotlib figure instance of the plot is returned.
            If ``show=False``, the plotted curve is returned.
        """

        curves = []
        all_secondary_sweep_value = secondary_sweep_value
        if primary_sweep.lower() == "freq" or primary_sweep.lower() == "frequency":
            x_key = "Freq"
            x = self.rcs_data.frequencies
            if secondary_sweep == "IWaveTheta":
                if all_secondary_sweep_value is None:
                    all_secondary_sweep_value = self.rcs_data.incident_wave_theta
                data = self.rcs_data.raw_data.xs(key=self.rcs_data.incident_wave_phi, level="IWavePhi")
                y_key = "IWaveTheta"
            else:
                if all_secondary_sweep_value is None:
                    all_secondary_sweep_value = self.rcs_data.incident_wave_phi
                data = self.rcs_data.raw_data.xs(key=self.rcs_data.incident_wave_theta, level="IWaveTheta")
                y_key = "IWavePhi"
            data = conversion_function(data[self.rcs_data.name], self.rcs_data.data_conversion_function)
        else:
            data = self.rcs_data.rcs
            if primary_sweep.lower() == "iwavephi":
                secondary_sweep = "IWaveTheta"
                x_key = "IWavePhi"
                y_key = "IWaveTheta"
                x = self.rcs_data.available_incident_wave_phi
                if isinstance(secondary_sweep_value, str) and secondary_sweep_value == "all":
                    all_secondary_sweep_value = self.rcs_data.available_incident_wave_theta
                elif secondary_sweep_value is None:
                    all_secondary_sweep_value = self.rcs_data.incident_wave_theta
            else:
                secondary_sweep = "IWavePhi"
                x_key = "IWaveTheta"
                y_key = "IWavePhi"
                x = self.rcs_data.available_incident_wave_theta
                if isinstance(secondary_sweep_value, str) and secondary_sweep_value == "all":
                    all_secondary_sweep_value = self.rcs_data.available_incident_wave_phi
                elif secondary_sweep_value is None:
                    all_secondary_sweep_value = self.rcs_data.incident_wave_phi

        if all_secondary_sweep_value is not None:
            if not isinstance(all_secondary_sweep_value, np.ndarray) and not isinstance(
                all_secondary_sweep_value, list
            ):
                all_secondary_sweep_value = [all_secondary_sweep_value]

            if is_polar:
                x = [i * 2 * math.pi / 360 for i in x]

            for el in all_secondary_sweep_value:
                data_sweep = data.xs(key=el, level=y_key)
                y = data_sweep.values
                if not isinstance(y, np.ndarray):  # pragma: no cover
                    raise Exception("Format of quantity is wrong.")
                curves.append([x, y, "{}={}".format(y_key, el)])

        if curves is not None:
            if is_polar:
                return plot_polar_chart(
                    curves,
                    xlabel=x_key,
                    ylabel="RCS",
                    title=title,
                    snapshot_path=output_file,
                    show_legend=show_legend,
                    show=show,
                )
            else:
                return plot_2d_chart(
                    curves,
                    xlabel=x_key,
                    ylabel="RCS",
                    title=title,
                    snapshot_path=output_file,
                    show_legend=show_legend,
                    show=show,
                )

    @pyaedt_function_handler()
    def plot_scene(self, show=True, plotter=None):
        """
        Plot the 3D scene including models, annotations, and results in a PyVista plotter.

        This method visualizes the 3D scene by rendering the mesh objects under the "model",
        "annotations", and "results" categories stored in `self.all_scene_actors`. The meshes
        are rendered using the specified `plotter` or a default PyVista plotter if none is provided.
        If a plotter is supplied and supports clearing, the scene is cleared before rendering.


        Parameters
        ----------
        show : bool, optional
            Whether to immediately display the plot. If ``True``, the plot will be displayed using ``plotter.show()``.
            If ``False``, the ``plotter`` object is returned for further customization before rendering.
            The default is ``True``.
        plotter : pyvista.Plotter, optional
            A pre-configured PyVista plotter to use for visualization. If not provided, a new plotter will be created
            with a ``PyVistaBackend`` allowing interaction with the model.

        Returns
        -------
        pyvista.Plotter or None
            Returns the ``plotter`` object if ``show`` is set to ``False``. If ``show`` is ``True``,
            the plot is displayed and no value is returned.
        """
        if not plotter:
            pv_backend = PyVistaBackend(allow_picking=True, plot_picked_names=True)
            plotter = Plotter(backend=pv_backend)
        else:
            if getattr(plotter, "clear", None):
                plotter.clear()
            elif getattr(plotter, "_backend", None):
                plotter._backend.pv_interface.scene.clear()

        if self.show_geometry:
            for geo in self.all_scene_actors["model"].values():
                self.__add_mesh(geo, plotter, "model")

        for annotations in self.all_scene_actors["annotations"]:
            for annotation in self.all_scene_actors["annotations"][annotations].values():
                if annotation.custom_object.show:
                    self.__add_mesh(annotation, plotter, "annotations")

        for all_scene_results in self.all_scene_actors["results"]:
            for result_actor in self.all_scene_actors["results"][all_scene_results].values():
                if getattr(result_actor, "custom_object", None) and result_actor.custom_object.show:
                    self.__add_mesh(result_actor, plotter, "results")
                elif getattr(result_actor, "show", None):
                    self.__add_mesh(result_actor, plotter, "results")

        if show:
            plotter.show()
        else:
            return plotter

    @pyaedt_function_handler()
    def add_rcs(
        self,
        color_bar="jet",
    ):
        """
        Add the 3D RCS.
        """
        data = self.rcs_data.rcs

        new_data = self.stretch_data(data, scaling_factor=self.extents[5] - self.extents[4], offset=self.extents[4])

        if new_data.values.min() < 0:
            values_renorm = new_data.values + np.abs(new_data.values.min())
        else:
            values_renorm = new_data.values

        phi = []
        theta = []
        values = []

        for (phi_val, theta_val), value in data.items():
            phi.append(np.deg2rad(phi_val))
            theta.append(np.deg2rad(theta_val))
            values.append(value)

        unique_phi = np.unique(phi)
        unique_theta = np.unique(theta)
        phi_grid, theta_grid = np.meshgrid(unique_phi, unique_theta)

        r = np.zeros(phi_grid.shape)

        # Populate the reshaped array
        for i, t in enumerate(np.unique(theta)):
            for j, p in enumerate(np.unique(phi)):
                # Find the corresponding value for each (phi, theta)
                idx = np.where((phi == p) & (theta == t))
                if idx[0].size > 0:
                    r[i, j] = values_renorm[idx[0][0]]

        x = r * np.sin(theta_grid) * np.cos(phi_grid)
        y = r * np.sin(theta_grid) * np.sin(phi_grid)
        z = r * np.cos(theta_grid)

        actor = pv.StructuredGrid(x, y, z)
        actor.point_data["values"] = data.values

        # plotter = pv.Plotter()
        # plotter.add_mesh(mesh, scalars="values", cmap="jet")
        # plotter.add_axes()
        # plotter.show()

        all_results_actors = list(self.all_scene_actors["results"].keys())

        if "rcs" not in all_results_actors:
            self.all_scene_actors["results"]["rcs"] = {}

        index = 0
        while f"rcs_{index}" in self.all_scene_actors["results"]["rcs"]:
            index += 1

        rcs_name = f"rcs_{index}"

        rcs_object = SceneMeshObject()
        rcs_object.name = rcs_name
        rcs_object.line_width = 1.0

        scalar_dict = dict(color="#000000", title="RCS")
        rcs_object.scalar_dict = scalar_dict

        if any(color_bar in x for x in ["blue", "green", "black", "red"]):
            rcs_object.color = color_bar
        else:
            rcs_object.cmap = color_bar

        rcs_object.mesh = actor
        #
        # rcs_mesh = MeshObjectPlot(rcs_object, rcs_object.get_mesh())

        self.all_scene_actors["results"]["rcs"][rcs_name] = rcs_object

    @pyaedt_function_handler()
    def add_range_profile_settings(self, size_range=10, range_resolution=0.1, tick_color="#000000"):
        # Compute parameters
        range_max = size_range - range_resolution
        range_num = int(np.round(size_range / range_resolution))
        distance_range = np.linspace(0, range_max, range_num)
        distance_range -= distance_range[range_num // 2]
        range_first = -distance_range[0]
        range_last = -distance_range[-1]
        z_mid = self.extents[5] + (self.extents[4] - self.extents[5]) / 2
        num_ticks = int(size_range / range_resolution)
        # Using 5% of total range length
        tick_length = size_range * 0.05

        if "range_profile" not in self.all_scene_actors["annotations"].keys():
            self.all_scene_actors["annotations"]["range_profile"] = {}

        # Main red line
        main_line = pv.Line(
            pointa=(range_first, self.extents[2] * 10, z_mid), pointb=(range_last, self.extents[2] * 10, z_mid)
        )
        annotation_name = "main_line"

        main_line_object = SceneMeshObject()
        main_line_object.name = annotation_name
        main_line_object.color = "red"
        main_line_object.line_width = 5
        main_line_object.mesh = main_line

        main_line_mesh = MeshObjectPlot(main_line_object, main_line_object.get_mesh())
        self.all_scene_actors["annotations"]["range_profile"][annotation_name] = main_line_mesh

        # Ticks
        tick_lines = pv.PolyData()
        for tick in range(num_ticks + 1):  # create line with tick marks
            if tick % 1 == 0:  # only do every nth tick
                tick_pos_start = (range_first - range_resolution * tick, self.extents[2] * 10, z_mid)
                tick_pos_end = (range_first - range_resolution * tick, self.extents[2] * 10 + tick_length, z_mid)
                tick_lines += pv.Line(pointa=tick_pos_start, pointb=tick_pos_end)

        annotation_name = "ticks"
        tick_lines_object = SceneMeshObject()
        tick_lines_object.name = annotation_name
        tick_lines_object.color = tick_color
        tick_lines_object.line_width = 2
        tick_lines_object.mesh = tick_lines

        tick_lines_mesh = MeshObjectPlot(tick_lines_object, tick_lines_object.get_mesh())
        self.all_scene_actors["annotations"]["range_profile"][annotation_name] = tick_lines_mesh

        start_geo = pv.Disc(
            center=(range_last, self.extents[2] * 10, z_mid), outer=tick_length, inner=0, normal=(-1, 0, 0), c_res=12
        )

        annotation_name = "disc"
        start_geo_object = SceneMeshObject()
        start_geo_object.name = annotation_name
        start_geo_object.color = "red"
        start_geo_object.line_width = 5
        start_geo_object.mesh = start_geo

        disc_geo_mesh = MeshObjectPlot(start_geo_object, start_geo_object.get_mesh())
        self.all_scene_actors["annotations"]["range_profile"][annotation_name] = disc_geo_mesh

        end_geo = pv.Cone(
            center=(range_first, self.extents[2] * 10, z_mid),
            direction=(-1, 0, 0),
            radius=tick_length,
            height=tick_length * 2,
            resolution=12,
        )
        annotation_name = "cone"
        end_geo_object = SceneMeshObject()
        end_geo_object.name = annotation_name
        end_geo_object.color = "green"
        end_geo_object.line_width = 5
        end_geo_object.mesh = end_geo

        end_geo_mesh = MeshObjectPlot(end_geo_object, end_geo_object.get_mesh())
        self.all_scene_actors["annotations"]["range_profile"][annotation_name] = end_geo_mesh

    @pyaedt_function_handler()
    def add_range_profile(
        self,
        plot_type="Line",
        radius_offset=0,
        waterfall=False,
        color_bar="jet",
    ):
        """
        Add the 3D range profile.
        """
        # categories = ["jet", "jet_r", "magma", "magma_r", "nipy_spectral", "coolwarm", "viridis", "gray", "gray_r",
        #               "seismic", "winter", "bone",
        #               "blue", "green", "black", "red"]
        data_range_profile = self.rcs_data.range_profile

        new_data = self.stretch_data(
            data_range_profile, scaling_factor=self.extents[5] - self.extents[4], offset=self.extents[4]
        )

        ranges = np.unique(new_data.index.get_level_values("Range"))
        phis = np.unique(new_data.index.get_level_values("IWavePhi"))
        thetas = np.unique(new_data.index.get_level_values("IWaveTheta"))

        add_offset = 0.0 if not waterfall else ranges[-1]

        cosphis = np.cos(np.radians(phis))
        sinphis = np.sin(np.radians(phis))
        sinthetas = np.sin(np.radians(thetas))
        xpos = (-ranges + radius_offset + add_offset) * cosphis * sinthetas
        ypos = (-ranges + radius_offset + add_offset) * sinphis * sinthetas
        zpos = None
        plot_data = new_data["data"].to_numpy()

        cpos = data_range_profile["data"].to_numpy()

        actor = self._get_pyvista_rcs_actor(
            xpos,
            ypos,
            zpos,
            plot_data,
            cpos,
            plot_type=plot_type,
            scene_actors=self.all_scene_actors["model"],
            data_conversion_function=self.rcs_data.data_conversion_function,
            extents=self.extents,
        )

        all_results_actors = list(self.all_scene_actors["results"].keys())

        if "range_profile" not in all_results_actors:
            self.all_scene_actors["results"]["range_profile"] = {}

        index = 0
        while f"range_profile_{index}" in self.all_scene_actors["results"]["range_profile"]:
            index += 1

        range_profile_name = f"range_profile_{index}"

        range_profile_object = SceneMeshObject()
        range_profile_object.name = range_profile_name
        range_profile_object.line_width = 1.0

        scalar_dict = dict(color="#000000", title="Range Profile")
        range_profile_object.scalar_dict = scalar_dict

        if any(color_bar in x for x in ["blue", "green", "black", "red"]):
            range_profile_object.color = color_bar
        else:
            range_profile_object.cmap = color_bar

        range_profile_object.mesh = actor

        range_profile_mesh = MeshObjectPlot(range_profile_object, range_profile_object.get_mesh())

        self.all_scene_actors["results"]["range_profile"][range_profile_name] = range_profile_mesh

    @pyaedt_function_handler()
    def clear_scene(self, first_level=None, second_level=None, name=None):
        if not first_level:
            self.all_scene_actors["annotations"] = {}
            self.all_scene_actors["results"] = {}
        elif first_level == "model":
            self.__logger.warning("Model can not be cleared. Set 'show_geometry' to False.")
            return False
        elif first_level in ["annotations", "results"]:
            if not second_level:
                self.all_scene_actor[first_level] = {}
            elif second_level in self.all_scene_actors[first_level].keys():
                if not name:
                    self.all_scene_actor[first_level][second_level] = {}
                elif name in self.all_scene_actors[first_level][second_level].keys():
                    del self.all_scene_actors[first_level][second_level][name]
        return True

    @pyaedt_function_handler()
    def _get_pyvista_rcs_actor(
        self,
        xpos,
        ypos,
        zpos,
        plot_data,
        cpos,
        plot_type="Line",
        data_conversion_function="",
        scene_actors=None,
        shape=None,
        extents=None,
    ):
        if extents is None:
            extents = [0, 10, 0, 10, 0, 10]

        plot_type_lower = plot_type.lower()
        actor = None

        if (
            plot_type_lower == "line"
            or plot_type_lower == "ribbon"
            or plot_type_lower == "rotated"
            or plot_type_lower == "extruded"
        ):
            xyz_pos = np.stack((xpos, ypos, plot_data)).T
            actor = pv.lines_from_points(xyz_pos)
            actor[data_conversion_function] = cpos
            if plot_type_lower == "ribbon":
                norm_vect = [0, 0, 1]
                # min_width_for_renorm, max_width_for_renorm = get_min_max_width_window(plotter)
                x_max, x_min = max(extents[0], extents[1]), min(extents[0], extents[1])
                y_max, y_min = max(extents[2], extents[3]), min(extents[2], extents[3])
                radius_max = max([abs(x_max), abs(x_min), abs(y_max), abs(y_min)])
                min_width_for_renorm = -radius_max
                max_width_for_renorm = radius_max
                geo_width = max_width_for_renorm - min_width_for_renorm
                actor = actor.ribbon(width=geo_width / 2, normal=norm_vect)
            elif plot_type_lower == "rotated":
                v = xyz_pos[-1] - xyz_pos[0]
                v_hat = v / np.linalg.norm(v)
                actor.extrude_rotate(rotation_axis=v_hat, capping=True, inplace=True)
            elif plot_type_lower == "extruded":
                plane = pv.Plane(
                    center=(actor.center[0], actor.center[1], actor.bounds[4]),
                    direction=(0, 0, -1),
                    i_size=actor.bounds[1] - actor.bounds[0],
                    j_size=actor.bounds[3] - actor.bounds[2],
                )
                actor.extrude_trim((0, 0, -1.0), plane, inplace=True)
        elif "donut" in plot_type_lower or "disk" in plot_type_lower:
            if "relief" not in plot_type_lower:
                plot_data = plot_data * 0 + model_center[2]
            actor = pv.StructuredGrid(xpos.reshape(shape), ypos.reshape(shape), plot_data.reshape(shape))
            actor[data_conversion_function] = np.ndarray.flatten(cpos.reshape(shape), order="F")
        elif plot_type_lower == "plane v" or plot_type_lower == "plane h":
            zpos = np.zeros(shape=plot_data.shape)
            xyz_pos = np.stack((xpos, ypos, zpos)).T
            actor = pv.lines_from_points(xyz_pos)
            actor[data_conversion_function] = cpos
            if plot_type_lower == "plane v":
                # min_height_for_renorm, max_height_for_renorm = get_min_max_height_window(plotter)
                geo_width = extents[5] - extents[4]
                norm_vect = [0, 1, 0]
            else:
                # min_width_for_renorm, max_width_for_renorm = get_min_max_width_window(plotter)
                x_max, x_min = max(extents[0], extents[1]), min(extents[0], extents[1])
                y_max, y_min = max(extents[2], extents[3]), min(extents[2], extents[3])
                radius_max = max([abs(x_max), abs(x_min), abs(y_max), abs(y_min)])
                min_width_for_renorm = -radius_max
                max_width_for_renorm = radius_max
                geo_width = max_width_for_renorm - min_width_for_renorm
                norm_vect = [0, 0, 1]
            actor = actor.ribbon(width=geo_width / 2, normal=norm_vect)
        elif plot_type_lower == "plane" or plot_type_lower == "relief":
            actor = pv.StructuredGrid(xpos.reshape(shape), ypos.reshape(shape), plot_data.reshape(shape))
            actor[data_conversion_function] = cpos.reshape(shape).flatten(order="F")
        elif plot_type_lower == "projection":
            if scene_actors is None:
                return None
            actor = pv.PolyData()
            for model_actor in scene_actors.values():
                mesh = model_actor.custom_object.get_mesh()
                xypoints = mesh.points
                xpos_ypos = np.column_stack((xpos, ypos, plot_data))
                _, all_indices = self.find_nearest_neighbors(xpos_ypos, xypoints)
                mag_for_color = np.ndarray.flatten(cpos[all_indices])
                if not mesh.__class__.__name__ == "PolyData":
                    mesh_triangulated = mesh.triangulate()
                    model_actor.custom_object.mesh = pv.PolyData(mesh_triangulated.points, mesh_triangulated.cells)
                else:
                    model_actor.custom_object.mesh.clear_data()
                model_actor.custom_object.mesh[data_conversion_function] = mag_for_color
                actor += model_actor.custom_object.mesh
        elif plot_type_lower == "point cloud" or plot_type_lower == "isosurface" or plot_type_lower == "plane cut":
            x = list(sorted(np.unique(xpos)))
            y = list(sorted(np.unique(ypos)))
            z = list(sorted(np.unique(zpos)))
            actor = pv.RectilinearGrid(x, y, z)
            actor[data_conversion_function] = cpos
        return actor

    @staticmethod
    def stretch_data(data, scaling_factor, offset):
        """
        Stretches and scales the input data to a specified range.

        This method normalizes the input data between its minimum and maximum values and then applies
        a linear transformation using the formula: ``scaled_data = (data - min) / (max - min) * m + b``.
        The parameters ``m`` and ``b`` control the scaling and shifting of the normalized data.

        Parameters
        ----------
        data : numpy.ndarray or pandas.Series
            The input data array or series to be stretched.
        scaling_factor : float
            The scaling factor applied to the normalized data.
        offset : float
            The offset added to the scaled data after normalization.

        Returns
        -------
        numpy.ndarray or pandas.Series
            Transformed data

        Example:
        -------
        >>> data = np.array([1, 2, 3, 4, 5])
        >>> stretched_data = stretch_data(data,2,1)
        >>> print(stretched_data)
        [1.  1.5 2.  2.5 3. ]
        """
        return (data - data.min()) / (data.max() - data.min()) * scaling_factor + offset

    @staticmethod
    def find_nearest_neighbors(xpos_ypos, xypoints):
        # Calculate squared Euclidean distance between each point in xypoints and xpos_ypos
        distances = np.sqrt(((xpos_ypos[:, np.newaxis] - xypoints) ** 2).sum(axis=2))

        # Find the index of the nearest neighbor for each query point in xypoints
        all_indices = np.argmin(distances, axis=0)

        # Get the distance for each query point (optional, can be removed if not needed)
        nearest_distances = np.min(distances, axis=0)

        return nearest_distances, all_indices

    @staticmethod
    def __add_mesh(mesh_object, plotter, mesh_type="results"):
        """Add a mesh to the plotter with additional options."""
        options = None
        if getattr(mesh_object, "custom_object", None):
            if mesh_type == "model":
                options = mesh_object.custom_object.get_model_options()
            elif mesh_type == "annotations":
                options = mesh_object.custom_object.get_annotation_options()
            else:
                options = mesh_object.custom_object.get_result_options()

        # TODO
        if isinstance(mesh_object.mesh, pv.StructuredGrid):
            if mesh_type == "model":
                options = mesh_object.get_model_options()
            elif mesh_type == "annotations":
                options = mesh_object.get_annotation_options()
            else:
                options = mesh_object.get_result_options()

        if options is None:
            options = {}
        if getattr(plotter, "plot", None):
            # TODO
            if isinstance(mesh_object.mesh, pv.StructuredGrid):
                plotter._backend.pv_interface.scene.add_mesh(mesh_object.mesh, **options)
            else:
                plotter.plot(mesh_object.mesh, **options)
        elif getattr(plotter, "add_mesh", None):
            plotter.add_mesh(mesh_object.mesh, **options)

    @pyaedt_function_handler()
    def __get_model_extent(self):
        """
        Calculate the 3D extent of the model by evaluating the bounding box dimensions
        of each mesh object in the scene.

        This method retrieves the maximum and minimum coordinates in the x, y, and z
        directions for all mesh objects stored under the "model" key in `self.all_scene_actors`.
        The bounding box of each mesh is assessed, and the overall bounds for the entire
        model are determined by taking the min/max values from these individual bounding boxes.
        """
        x_max, x_min, y_max, y_min, z_max, z_min = [], [], [], [], [], []

        if len(self.all_scene_actors["model"]) == 0:
            x_max = [10]
            x_min = [0]
            y_max = [10]
            y_min = [0]
            z_max = [10]
            z_min = [0]
        for each in self.all_scene_actors["model"].values():
            x_max.append(each.mesh.bounds[1])
            x_min.append(each.mesh.bounds[0])
            y_max.append(each.mesh.bounds[3])
            y_min.append(each.mesh.bounds[2])
            z_max.append(each.mesh.bounds[5])
            z_min.append(each.mesh.bounds[4])
        self.__x_max, self.__x_min = max(x_max), min(x_min)
        self.__y_max, self.__y_min = max(y_max), min(y_min)
        self.__z_max, self.__z_min = max(z_max), min(z_min)

    @pyaedt_function_handler()
    def __get_geometry(self, off_screen=False):
        """Get 3D meshes."""
        model_info = self.model_info
        obj_meshes = {}
        model_pv = ModelPlotter()
        first_value = next(iter(model_info.values()))
        self.__model_units = first_value[3]
        model_pv.off_screen = off_screen
        for object_in in model_info.values():
            cad_path = os.path.join(self.rcs_data.output_dir, object_in[0])
            if os.path.exists(cad_path):
                model_pv.add_object(
                    cad_path,
                    object_in[1],
                    object_in[2],
                    object_in[3],
                )
            else:
                self.logger.warning(f"{cad_path} does not exist.")
                return False
        self.__model_units = first_value[3]
        model_pv.generate_geometry_mesh()
        for obj in model_pv.objects:
            # mesh = obj._cached_polydata
            # translated_mesh = mesh.copy()
            color_cad = [i / 255 for i in obj.color]
            obj.color = color_cad

            model_object = SceneMeshObject()
            model_object.color = color_cad
            model_object.opacity = obj.opacity
            model_object.name = obj.name
            model_object.mesh = obj._cached_polydata

            mesh_object = MeshObjectPlot(model_object, model_object.get_mesh())
            obj_meshes[obj.name] = mesh_object
        model_pv.close()
        return obj_meshes


class SceneMeshObject:
    """
    A class representing a custom 3D mesh object with visualization properties.

    This class defines a 3D mesh object with customizable properties.
    It provides methods to retrieve the mesh, its associated rendering options, and annotation properties for
    visualization in PyVista.

    """

    def __init__(self):
        # Public
        self.name = "CustomObject"
        self.opacity = 1.0
        self.color = None
        self.color_map = "jet"
        self.line_width = 1.0
        self.scalar_dict = dict(color="#000000", title="Dummy")
        self.show = True

        # Private
        self.__mesh = pv.Cube()
        self.__original_points = self.mesh.points.copy()
        self.__z_offset = 0.0
        self.__scale_factor = 1.0

    @property
    def mesh(self):
        return self.__mesh

    @mesh.setter
    def mesh(self, val):
        self.__mesh = val
        self.__original_points = val.points.copy()

    @property
    def z_offset(self):
        return self.__z_offset

    @z_offset.setter
    def z_offset(self, val):
        translation_distance = val

        # Calculate the new points by applying the translation to the original points
        new_points = self.__original_points.copy()
        new_points[:, 2] += translation_distance  # Apply Z translation

        # Update the mesh with the new points
        self.__mesh.points = new_points
        self.__z_offset = val

    @property
    def scale_factor(self):
        """Get the current scale factor."""
        return self.__scale_factor

    @scale_factor.setter
    def scale_factor(self, val):
        """Set a new scale factor and update the mesh accordingly."""
        scale_factor = val

        # Calculate the center of the mesh for scaling
        center = self.__mesh.points.mean(axis=0)  # Center of the original mesh

        # Calculate the new points by scaling relative to the original points and the mesh center
        new_points = self.__mesh.points.copy()
        new_points = center + (new_points - center) * scale_factor  # Apply scaling from the center

        # Update the mesh with the new points
        self.mesh.points = new_points
        self.__scale_factor = val  # Update the scale factor

    def reset_scene(self):
        """Reset the mesh to its original position and size."""
        self.mesh.points = self.__original_points.copy()  # Restore the original points
        self.__z_offset = 0.0  # Reset the Z-offset
        self.__scale_factor = 1.0  # Reset the scale factor

    def get_mesh(self):
        """Retrieve the mesh object.

        Returns
        -------
        pyvista.PolyData or pyvista.UnstructuredGrid
            The mesh object representing the 3D geometry.
        """
        return self.mesh

    def show(self):
        """Show mesh."""
        return self.show

    def name(self):
        """Name."""
        return self.name

    def line_width(self):
        """Line width."""
        return self.name

    def opacity(self):
        """Opacity."""
        return self.opacity

    def color(self):
        """Color."""
        return self.color

    def color_map(self):
        """Color map."""
        return self.color_map

    def scalar_dict(self):
        """Scalar bar dict."""
        return self.scalar_dict

    def get_model_options(self):
        """Retrieve the visualization options for the mesh.

        Returns
        -------
        dict
            A dictionary with the color and opacity settings for rendering the model.
        """
        return {"color": self.color, "opacity": self.opacity}

    def get_annotation_options(self):
        """Retrieve the annotation options for the mesh.

        Returns
        -------
        dict
            A dictionary with the color and line width settings for annotating the model.
        """
        return {"color": self.color, "line_width": self.line_width}

    def get_result_options(self):
        """Retrieve the result options for the mesh.

        Returns
        -------
        dict
            A dictionary with the settings for results the model.
        """
        if self.color:
            return {"color": self.color, "line_width": self.line_width, "scalar_bar_args": self.scalar_dict}
        return {"cmap": self.color_map, "line_width": self.line_width, "scalar_bar_args": self.scalar_dict}
