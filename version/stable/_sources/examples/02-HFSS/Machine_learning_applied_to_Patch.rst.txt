
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples\02-HFSS\Machine_learning_applied_to_Patch.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_02-HFSS_Machine_learning_applied_to_Patch.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_02-HFSS_Machine_learning_applied_to_Patch.py:


HFSS: machine learning applied to a patch
-----------------------------------------
This example shows how you can use PyAEDT to create a machine learning algorithm in three steps:

#. Generate the database.
#. Create the machine learning algorithm.
#. Implement the model in a PyAEDT method.

While this example supplies the code for all three steps in one Python file, it would be
better to separate the code for each step into its own Python file.

.. GENERATED FROM PYTHON SOURCE LINES 14-17

Perform required imports
~~~~~~~~~~~~~~~~~~~~~~~~
Perform required imports.

.. GENERATED FROM PYTHON SOURCE LINES 17-32

.. code-block:: default


    import json
    import os
    import random
    from math import sqrt

    import joblib
    import numpy as np
    from sklearn.pipeline import make_pipeline
    from sklearn.preprocessing import StandardScaler
    from sklearn.svm import SVR

    from pyaedt import Hfss
    from pyaedt.modeler.advanced_cad.stackup_3d import Stackup3D








.. GENERATED FROM PYTHON SOURCE LINES 33-38

Set non-graphical mode
~~~~~~~~~~~~~~~~~~~~~~
Set non-graphical mode. ``"PYAEDT_NON_GRAPHICAL"`` is needed to generate
documentation only.
You can set ``non_graphical`` either to ``True`` or ``False``.

.. GENERATED FROM PYTHON SOURCE LINES 38-41

.. code-block:: default


    non_graphical = False








.. GENERATED FROM PYTHON SOURCE LINES 42-58

Generate database
-------------------
This section describes the first step, which is for generating the database.

Generate input
~~~~~~~~~~~~~~
Generate input randomly by creating a function with four inputs: frequency,
substrate permittivity, substrate thickness, and patch width. Frequency ranges
from 0.1 GHz to 1 GHz. Permittivity is from 1 to 12.

The following code generates a database of 1 frequency x 2 permittivity
x 2 thickness x 2 width. It creates eight cases, which are far too few to
use to train the model but are a sufficient number for testing
the model. Later in this example, you import more than 3,300 different 
cases in a previously generated database of 74 frequencies
x 5 permittivity x 3 thickness x 3 width.

.. GENERATED FROM PYTHON SOURCE LINES 58-67

.. code-block:: default


    tuple_random_frequency_permittivity = []
    frequency_list = [150 * 1e6]
    for in_list in frequency_list:
        for i in range(2):
            random_permittivity = 1 + 11 * int(random.random() * 100) / 100
            temp_tuple = (in_list, random_permittivity)
            tuple_random_frequency_permittivity.append(temp_tuple)








.. GENERATED FROM PYTHON SOURCE LINES 68-78

Thickness is generated from 0.0025 to 0.055 of the wavelength in the void.
Width is generated from 0.5 to 1.5 of the optimal theoretical width:

``c / (2 * frequency * sqrt((permittivity + 1) / 2))``

For each couple of frequency-permittivity, three random thicknesses and three
random widths are generated. Patch length is calculated using the analytic
formula. Using this formula is important because it reduces the sweep
frequency needed for the data recovery. Every case is stored in a list of a
dictionary.

.. GENERATED FROM PYTHON SOURCE LINES 78-127

.. code-block:: default


    dictionary_list = []
    c = 2.99792458e8
    for couple in tuple_random_frequency_permittivity:
        list_thickness = []
        list_width = []
        frequency = couple[0]
        permittivity = couple[1]
        er = permittivity
        wave_length_0 = c / frequency

        min_thickness = 0.0025 * wave_length_0
        inter_thickness = 0.01 * wave_length_0
        max_thickness = 0.055 * wave_length_0
        for i in range(2):
            random_int = random.randint(0, 1)
            if random_int == 0:
                thickness = min_thickness + (inter_thickness - min_thickness) * random.random()
            else:
                thickness = inter_thickness + (max_thickness - inter_thickness) * random.random()
            list_thickness.append(thickness)

        min_width = 0.5 * c / (2 * frequency * sqrt((er + 1) / 2))
        max_width = 1.5 * c / (2 * frequency * sqrt((er + 1) / 2))
        for i in range(2):
            width = min_width + (max_width - min_width) * random.random()
            list_width.append(width)

        for width in list_width:
            for thickness in list_thickness:
                effective_permittivity = (er + 1) / 2 + (er - 1) / (2 * sqrt(1 + 10 * thickness / width))
                er_e = effective_permittivity
                w_h = width / thickness
                added_length = 0.412 * thickness * (er_e + 0.3) * (w_h + 0.264) / ((er_e - 0.258) * (w_h + 0.813))
                wave_length = c / (frequency * sqrt(er_e))
                length = wave_length / 2 - 2 * added_length
                dictionary = {
                    "frequency": frequency,
                    "permittivity": permittivity,
                    "thickness": thickness,
                    "width": width,
                    "length": length,
                    "previous_impedance": 0,
                }
                dictionary_list.append(dictionary)

    print("List of data: " + str(dictionary_list))
    print("Its length is: " + str(len(dictionary_list)))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    List of data: [{'frequency': 150000000.0, 'permittivity': 7.05, 'thickness': 0.017167340876279334, 'width': 0.7292653267370429, 'length': 0.36956389788678345, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 7.05, 'thickness': 0.07174297986464825, 'width': 0.7292653267370429, 'length': 0.34075934072048353, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 7.05, 'thickness': 0.017167340876279334, 'width': 0.45561564594087284, 'length': 0.3738094049832851, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 7.05, 'thickness': 0.07174297986464825, 'width': 0.45561564594087284, 'length': 0.3510774748820171, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 11.34, 'thickness': 0.018745061158339307, 'width': 0.521796708660778, 'length': 0.290903277603965, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 11.34, 'thickness': 0.007077149668080471, 'width': 0.521796708660778, 'length': 0.29492062614595255, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 11.34, 'thickness': 0.018745061158339307, 'width': 0.20630840221418928, 'length': 0.3018248097859602, 'previous_impedance': 0}, {'frequency': 150000000.0, 'permittivity': 11.34, 'thickness': 0.007077149668080471, 'width': 0.20630840221418928, 'length': 0.3004524457349059, 'previous_impedance': 0}]
    Its length is: 8




.. GENERATED FROM PYTHON SOURCE LINES 128-134

Generate HFSS design
~~~~~~~~~~~~~~~~~~~~
Generate the HFSS design using the ``Stackup3D`` method.
Open an HFSS design and create the stackup, add the different layers, and add
the patch. In the stackup library, most things, like the layers and patch,
are already parametrized.

.. GENERATED FROM PYTHON SOURCE LINES 134-147

.. code-block:: default


    desktopVersion = "2023.1"

    hfss = Hfss(
        new_desktop_session=True, solution_type="Terminal", non_graphical=non_graphical, specified_version=desktopVersion
    )

    stackup = Stackup3D(hfss)
    ground = stackup.add_ground_layer("ground", material="copper", thickness=0.035, fill_material="air")
    dielectric = stackup.add_dielectric_layer("dielectric", thickness=10, material="Duroid (tm)")
    signal = stackup.add_signal_layer("signal", material="copper", thickness=0.035, fill_material="air")
    patch = signal.add_patch(patch_length=1009.86, patch_width=1185.9, patch_name="Patch", frequency=100e6)








.. GENERATED FROM PYTHON SOURCE LINES 148-151

Resize layers around patch
~~~~~~~~~~~~~~~~~~~~~~~~~~
Resize the layers around the patch so that they change when the patch changes.

.. GENERATED FROM PYTHON SOURCE LINES 151-154

.. code-block:: default


    stackup.resize_around_element(patch)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    True



.. GENERATED FROM PYTHON SOURCE LINES 155-158

Create lumped port
~~~~~~~~~~~~~~~~~~
Create a lumped port that is parametrized with the function of the patch.

.. GENERATED FROM PYTHON SOURCE LINES 158-161

.. code-block:: default


    patch.create_lumped_port(reference_layer=ground, opposite_side=False, port_name="one")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <pyaedt.modules.Boundary.BoundaryObject object at 0x00000228925909A0>



.. GENERATED FROM PYTHON SOURCE LINES 162-166

Create line
~~~~~~~~~~~
Create a line that is parametrized with the function of the patch length. This
ensures that the air box is large enough in the normal direction of the patch.

.. GENERATED FROM PYTHON SOURCE LINES 166-176

.. code-block:: default


    points_list = [
        [patch.position_x.name, patch.position_y.name, signal.elevation.name],
        [patch.position_x.name, patch.position_y.name, signal.elevation.name + " + " + patch.length.name],
    ]
    hfss.modeler.create_polyline(position_list=points_list, name="adjust_airbox")
    pad_percent = [50, 50, 300, 50, 50, 10]
    region = hfss.modeler.create_region(pad_percent)
    hfss.assign_radiation_boundary_to_objects(region)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <pyaedt.modules.Boundary.BoundaryObject object at 0x00000228A8970640>



.. GENERATED FROM PYTHON SOURCE LINES 177-180

Plot
~~~~
Plot patch

.. GENERATED FROM PYTHON SOURCE LINES 180-183

.. code-block:: default


    hfss.plot(show=False, export_path=os.path.join(hfss.working_directory, "Image.jpg"), plot_air_objects=True)




.. image-sg:: /examples/02-HFSS/images/sphx_glr_Machine_learning_applied_to_Patch_001.png
   :alt: Machine learning applied to Patch
   :srcset: /examples/02-HFSS/images/sphx_glr_Machine_learning_applied_to_Patch_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <pyaedt.generic.plot.ModelPlotter object at 0x00000228A631C8B0>



.. GENERATED FROM PYTHON SOURCE LINES 184-187

Create setup and sweep
~~~~~~~~~~~~~~~~~~~~~~
Create a setup and a sweep by frequency.

.. GENERATED FROM PYTHON SOURCE LINES 187-214

.. code-block:: default


    print(len(dictionary_list))
    for freq in frequency_list:
        frequency_name = str(int(freq * 1e-6))
        setup_name = "Setup_" + str(frequency_name)
        current_setup = hfss.create_setup(setupname=setup_name)
        current_setup.props["Frequency"] = str(freq) + "Hz"
        current_setup.props["MaximumPasses"] = 30
        current_setup.props["MinimumConvergedPasses"] = 2
        current_setup.props["MaxDeltaS"] = 0.05
        current_setup.update()
        current_setup["SaveAnyFields"] = False

        freq_start = freq * 0.75
        freq_stop = freq * 1.25
        sweep_name = "Sweep_of_" + setup_name
        hfss.create_linear_count_sweep(
            setupname=setup_name,
            unit="Hz",
            freqstart=freq_start,
            freqstop=freq_stop,
            num_of_freq_points=25000,
            sweepname="Sweep_of_" + setup_name,
            save_fields=False,
            sweep_type="Interpolating",
        )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    8




.. GENERATED FROM PYTHON SOURCE LINES 215-218

Define function
~~~~~~~~~~~~~~~
Define a function to recover the index of the resonance frequency.

.. GENERATED FROM PYTHON SOURCE LINES 218-242

.. code-block:: default



    def index_of_resonance(imaginary_list, real_list):
        list_of_index = []
        for i in range(1, len(imaginary_list)):
            if imaginary_list[i] * imaginary_list[i - 1] < 0:
                if abs(imaginary_list[i]) < abs(imaginary_list[i - 1]):
                    list_of_index.append(i)
                elif abs(imaginary_list[i]) > abs(imaginary_list[i - 1]):
                    list_of_index.append(i - 1)
        if len(list_of_index) == 0:
            return 0
        elif len(list_of_index) == 1:
            return list_of_index[0]
        else:
            storage = 0
            resonance_index = 0
            for index in list_of_index:
                if storage < real_list[index]:
                    storage = real_list[index]
                    resonance_index = index
            return resonance_index









.. GENERATED FROM PYTHON SOURCE LINES 243-252

Create parametric variation by case
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Use a loop to create a parametric variation by case and associate it with a setup.
The parametric variation is composed of the patch length and width and substrate
permittivity and thickness. For each, measure the real resonance frequency to
obtain the data length, width, permittivity, and thickness that corresponds
to a resonance frequency. Use an error counter to verify that the resonance
frequency is contained in the sweep. To make it easy, calculate the length
of each case using the analytic formula.

.. GENERATED FROM PYTHON SOURCE LINES 252-321

.. code-block:: default


    error_counter = []
    for i in range(len(dictionary_list)):
        dictio = dictionary_list[i]
        frequency_name = str(int(dictio["frequency"] * 1e-6))
        setup_name = "Setup_" + str(frequency_name)
        sweep_name = "Sweep_of_" + setup_name
        length_variation = dictio["length"] * 1e3
        width_variation = dictio["width"] * 1e3
        thickness_variation = dictio["thickness"] * 1e3
        permittivity_variation = dictio["permittivity"]
        param_name = "para_" + setup_name + "_" + str(i)
        this_param = hfss.parametrics.add(
            patch.length.name,
            length_variation,
            length_variation,
            step=1,
            variation_type="LinearCount",
            solution=setup_name,
            parametricname=param_name,
        )
        this_param.add_variation(
            patch.width.name, width_variation, width_variation, step=1, unit=None, variation_type="LinearCount"
        )
        this_param.add_variation(
            dielectric.thickness.name,
            thickness_variation,
            thickness_variation,
            step=1,
            unit=None,
            variation_type="LinearCount",
        )
        this_param.add_variation(
            "$cloned_Duroid__tm__permittivity",
            permittivity_variation,
            permittivity_variation,
            step=1,
            unit=None,
            variation_type="LinearCount",
        )
        hfss.analyze_setup(param_name, num_cores=4, num_tasks=None)
        data = hfss.post.get_solution_data(
            "Zt(one_T1, one_T1)",
            setup_sweep_name=setup_name + " : " + sweep_name,
            domain="Sweep",
            variations={
                patch.length.name: [str(length_variation) + "mm"],
                patch.width.name: [str(width_variation) + "mm"],
                dielectric.thickness.name: [str(thickness_variation) + "mm"],
                "$cloned_Duroid__tm__permittivity": [str(permittivity_variation)],
            },
            polyline_points=25000,
        )
        imaginary_part = data.data_imag()
        real_part = data.data_real()
        corresponding_index = index_of_resonance(imaginary_part, real_part)
        if corresponding_index == 0:
            hfss.logger.error("The resonance is out of the range")
            error_counter.append(i)
        minimum_imaginary = imaginary_part[corresponding_index]
        previous_impedance = real_part[corresponding_index]
        print("minimum_imaginary: " + str(minimum_imaginary))
        print("previous_impedance: " + str(previous_impedance))
        frequency_list = data.primary_sweep_values
        resonance_frequency = frequency_list[corresponding_index]
        print(resonance_frequency)
        dictio["frequency"] = resonance_frequency
        dictio["previous_impedance"] = previous_impedance





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    minimum_imaginary: -0.03195903402984894
    previous_impedance: 223.55206022785217
    0.140959138365535
    minimum_imaginary: 0.04394332336423931
    previous_impedance: 203.5890720477238
    0.13447587903516098
    minimum_imaginary: -0.4060509360694228
    previous_impedance: 307.84985106032974
    0.144886295451818
    minimum_imaginary: -0.08697421953893643
    previous_impedance: 246.78762300551483
    0.135144905796232
    minimum_imaginary: 0.6732525417100504
    previous_impedance: 258.8678186579897
    0.13698697947917898
    minimum_imaginary: 0.6321019187363516
    previous_impedance: 216.99823927205358
    0.139249069962799
    minimum_imaginary: -0.1297805591153108
    previous_impedance: 421.92937564736405
    0.141055142205688
    minimum_imaginary: 1.0312220399860994
    previous_impedance: 444.1476191071969
    0.143092223688948




.. GENERATED FROM PYTHON SOURCE LINES 322-325

Print error
~~~~~~~~~~~
Print the number of range error.

.. GENERATED FROM PYTHON SOURCE LINES 325-328

.. code-block:: default


    print("number of range error: " + str(error_counter))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of range error: []




.. GENERATED FROM PYTHON SOURCE LINES 329-333

End data recovery step
~~~~~~~~~~~~~~~~~~~~~~
End the data recovery step by dumping the dictionary list into a JSON file.
Saving the data allows you to use it in another Python script.

.. GENERATED FROM PYTHON SOURCE LINES 333-338

.. code-block:: default


    json_file_path = os.path.join(hfss.working_directory, "ml_data_for_test.json")
    with open(json_file_path, "w") as readfile:
        json.dump(dictionary_list, readfile)








.. GENERATED FROM PYTHON SOURCE LINES 339-349

Create machine learning algorithm
----------------------------------
This section describes the second step, which is for creating the machine
learning algorithm.

Import training cases
~~~~~~~~~~~~~~~~~~~~~
Import the 3,300 cases in the supplied JSON file to train the model. As mentioned
earlier, you cannot use the small database that you generated earlier for training
the model. Its 8 cases are used later to test the model.

.. GENERATED FROM PYTHON SOURCE LINES 349-361

.. code-block:: default


    path_folder = hfss.pyaedt_dir
    training_file = os.path.join(path_folder, "misc", "ml_data_file_train_100MHz_1GHz.json")
    with open(training_file) as readfile:
        my_dictio_list_train = json.load(readfile)

    with open(json_file_path, "r") as readfile:
        my_dictio_list_test = json.load(readfile)

    print(len(my_dictio_list_train))
    print(len(my_dictio_list_test))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    3330
    8




.. GENERATED FROM PYTHON SOURCE LINES 362-370

Create lists
~~~~~~~~~~~~
Create four lists:

- One for the input of the training
- One for the output of training
- Oone for the input of the test
- One for the output of the test

.. GENERATED FROM PYTHON SOURCE LINES 370-376

.. code-block:: default


    input_for_training_list = []
    output_for_training_list = []
    input_for_test_list = []
    output_for_test_list = []








.. GENERATED FROM PYTHON SOURCE LINES 377-382

Fill list for input of training
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Fill the list for the input of the training with frequency, width, permittivity,
and thickness so that the output is the length. The objective of this
algorithm is to predict the length according to the rest.

.. GENERATED FROM PYTHON SOURCE LINES 382-408

.. code-block:: default


    for i in range(len(my_dictio_list_train)):
        freq_width_perm_thick = [
            my_dictio_list_train[i]["frequency"] * 1e9,
            my_dictio_list_train[i]["width"] * 1000,
            my_dictio_list_train[i]["permittivity"],
            my_dictio_list_train[i]["thickness"] * 1000,
        ]
        length = my_dictio_list_train[i]["length"] * 1000
        input_for_training_list.append(freq_width_perm_thick)
        output_for_training_list.append(length)

    for i in range(len(my_dictio_list_test)):
        freq_width_perm_thick = [
            my_dictio_list_test[i]["frequency"] * 1e9,
            my_dictio_list_test[i]["width"] * 1000,
            my_dictio_list_test[i]["permittivity"],
            my_dictio_list_test[i]["thickness"] * 1000,
        ]
        length = my_dictio_list_test[i]["length"] * 1000
        input_for_test_list.append(freq_width_perm_thick)
        output_for_test_list.append(length)

    print("number of test cases: " + str(len(output_for_test_list)))
    print("number of training cases: " + str(len(output_for_training_list)))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of test cases: 8
    number of training cases: 3330




.. GENERATED FROM PYTHON SOURCE LINES 409-412

Convert lists in array
~~~~~~~~~~~~~~~~~~~~~~
Convert the lists in an array.

.. GENERATED FROM PYTHON SOURCE LINES 412-421

.. code-block:: default


    input_for_training_array = np.array(input_for_training_list, dtype=np.float32)
    output_for_training_array = np.array(output_for_training_list, dtype=np.float32)
    input_for_test_array = np.array(input_for_test_list, dtype=np.float32)
    output_for_test_array = np.array(output_for_test_list, dtype=np.float32)

    print("input array for training: " + str(input_for_training_array))
    print("output array for training: " + str(output_for_training_array))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    input array for training: [[8.5343952e+07 1.8699978e+03 1.0000000e+00 1.3607236e+02]
     [8.7562560e+07 1.8699978e+03 1.0000000e+00 3.1649155e+01]
     [8.5523544e+07 1.8699978e+03 1.0000000e+00 1.6327014e+02]
     ...
     [9.5384678e+08 3.3421940e+01 1.1450000e+01 1.0995456e+01]
     [1.1057147e+09 3.3421940e+01 1.1450000e+01 2.1035936e+00]
     [9.7680755e+08 3.3421940e+01 1.1450000e+01 1.3259815e+01]]
    output array for training: [1463.626    1607.3876   1427.5016   ...   36.353287   39.326664
       35.355724]




.. GENERATED FROM PYTHON SOURCE LINES 422-442

Create model
~~~~~~~~~~~~
Create the model. Depending on the app, you can use different models.
The easiest way to find the correct model for an app is to search
for this app or one that is close to it.

To predict characteristics of a patch antenna (resonance frequency, bandwidth,
and input impedance), you can use SVR (Support Vector Regression) or ANN
(Analyze Neuronal Network). The following code uses SVR because it is easier
to implement. ANN is a more general method that also works with other
high frequency components. While it is more likely to work for other app,
implementing ANN is much more complex.

For SVR, there are three different kernels. For the patch antenna, RBF (Radial Basic
Function) is preferred. There are three other arguments that have a big impact
on the accuracy of the model: C, gamma, and epsilon. Sometimes they are given
with the necessary model for the app. Otherwise, you can try different
values and see which one is the best by measuring the accuracy of the model.
To make this example shorter, ``C=1e4``. However, the optimal value
in this app is ``C=5e4``.

.. GENERATED FROM PYTHON SOURCE LINES 442-446

.. code-block:: default


    svr_rbf = SVR(kernel="rbf", C=1e4, gamma="auto", epsilon=0.05)
    regression = make_pipeline(StandardScaler(), svr_rbf)








.. GENERATED FROM PYTHON SOURCE LINES 447-450

Train model
~~~~~~~~~~~
Train the model.

.. GENERATED FROM PYTHON SOURCE LINES 450-453

.. code-block:: default


    regression.fit(input_for_training_array, output_for_training_array)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <style>#sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler()),
                    (&#x27;svr&#x27;, SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;))])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item sk-dashed-wrapped"><div class="sk-label-container"><div class="sk-label sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" ><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">Pipeline</label><div class="sk-toggleable__content"><pre>Pipeline(steps=[(&#x27;standardscaler&#x27;, StandardScaler()),
                    (&#x27;svr&#x27;, SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;))])</pre></div></div></div><div class="sk-serial"><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-2" type="checkbox" ><label for="sk-estimator-id-2" class="sk-toggleable__label sk-toggleable__label-arrow">StandardScaler</label><div class="sk-toggleable__content"><pre>StandardScaler()</pre></div></div></div><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-3" type="checkbox" ><label for="sk-estimator-id-3" class="sk-toggleable__label sk-toggleable__label-arrow">SVR</label><div class="sk-toggleable__content"><pre>SVR(C=10000.0, epsilon=0.05, gamma=&#x27;auto&#x27;)</pre></div></div></div></div></div></div></div>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 454-458

Dump model into JOBLIB file
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Dump the model into a JOBLIB file using the same method as you used earlier
for the JSON file.

.. GENERATED FROM PYTHON SOURCE LINES 458-462

.. code-block:: default


    model_file = os.path.join(hfss.working_directory, "svr_model.joblib")
    joblib.dump(regression, model_file)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    ['D:/Project680.pyaedt\\HFSS_9SQ\\svr_model.joblib']



.. GENERATED FROM PYTHON SOURCE LINES 463-473

Implement model in PyAEDT method
-------------------------------------
This section describes the third step, which is for implementing the model
in the PyAEDT method.

Load model
~~~~~~~~~~
Load the model in another Python file to predict different cases.
Here the correct model with ``C=5e4`` is loaded rather than the one you made
earlier with ``C=1e4``.

.. GENERATED FROM PYTHON SOURCE LINES 473-477

.. code-block:: default


    model_path = os.path.join(path_folder, "misc", "patch_svr_model_100MHz_1GHz.joblib")
    regression = joblib.load(model_path)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:288: UserWarning: Trying to unpickle estimator StandardScaler from version 1.0.2 when using version 1.2.0. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(
    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:288: UserWarning: Trying to unpickle estimator SVR from version 1.0.2 when using version 1.2.0. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(
    c:\actions-runner\_work\pyaedt\pyaedt\testenv\lib\site-packages\sklearn\base.py:288: UserWarning: Trying to unpickle estimator Pipeline from version 1.0.2 when using version 1.2.0. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
    https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
      warnings.warn(




.. GENERATED FROM PYTHON SOURCE LINES 478-482

Predict length of patch
~~~~~~~~~~~~~~~~~~~~~~~
Predict the length of the patch as a function of its resonant frequency and width
and substrate thickness and permittivity.

.. GENERATED FROM PYTHON SOURCE LINES 482-485

.. code-block:: default


    prediction_of_length = regression.predict(input_for_test_list)








.. GENERATED FROM PYTHON SOURCE LINES 486-489

Measure model efficiency
~~~~~~~~~~~~~~~~~~~~~~~~
Measure the model efficiency.

.. GENERATED FROM PYTHON SOURCE LINES 489-541

.. code-block:: default


    average_relative_gap = 0
    counter_under_zero_five = 0
    counter_under_one = 0
    counter_under_two = 0
    counter_under_five = 0
    counter_under_ten = 0
    counter_upper_ten = 0
    rel_counter_under_one = 0
    rel_counter_under_two = 0
    rel_counter_under_five = 0
    rel_counter_under_ten = 0
    rel_counter_under_twenty = 0
    rel_counter_upper_twenty = 0
    for index in range(len(prediction_of_length)):
        print(
            "value: "
            + str(input_for_test_list[index])
            + ", prediction: "
            + str(prediction_of_length[index] * 1000)
            + ", reality: "
            + str(output_for_test_list[index] * 1000)
        )
        gap = abs(prediction_of_length[index] - output_for_test_list[index])
        relative_gap = gap / output_for_test_list[index]
        average_relative_gap = average_relative_gap + relative_gap
        if gap < 0.5:
            counter_under_zero_five += 1
        elif 0.5 <= gap < 1:
            counter_under_one += 1
        elif 1 <= gap < 2:
            counter_under_two += 1
        elif 2 <= gap < 5:
            counter_under_five += 1
        elif 5 <= gap < 10:
            counter_under_ten += 1
        else:
            counter_upper_ten += 1
        if relative_gap < 0.01:
            rel_counter_under_one += 1
        elif relative_gap < 0.02:
            rel_counter_under_two += 1
        elif relative_gap < 0.05:
            rel_counter_under_five += 1
        elif relative_gap < 0.1:
            rel_counter_under_ten += 1
        elif relative_gap < 0.2:
            rel_counter_under_twenty += 1
        else:
            rel_counter_upper_twenty += 1
    average_relative_gap = average_relative_gap / len(prediction_of_length)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    value: [140959138.365535, 729.2653267370429, 7.05, 17.167340876279333], prediction: 381883.17395798914, reality: 369563.89788678347
    value: [134475879.035161, 729.2653267370429, 7.05, 71.74297986464825], prediction: 351051.1889030876, reality: 340759.3407204835
    value: [144886295.451818, 455.6156459408728, 7.05, 17.167340876279333], prediction: 360304.9130691634, reality: 373809.40498328506
    value: [135144905.796232, 455.6156459408728, 7.05, 71.74297986464825], prediction: 359743.2357790879, reality: 351077.4748820171
    value: [136986979.479179, 521.796708660778, 11.34, 18.745061158339308], prediction: 323883.205322395, reality: 290903.277603965
    value: [139249069.962799, 521.796708660778, 11.34, 7.07714966808047], prediction: 303066.6806002789, reality: 294920.62614595256
    value: [141055142.205688, 206.30840221418927, 11.34, 18.745061158339308], prediction: 281339.6737263697, reality: 301824.8097859602
    value: [143092223.688948, 206.30840221418927, 11.34, 7.07714966808047], prediction: 255638.04450956787, reality: 300452.44573490595




.. GENERATED FROM PYTHON SOURCE LINES 542-544

The first displays are the gap ``(prediction - real)``. The second displays are
the relative gap ``((prediction - real)/real)``.

.. GENERATED FROM PYTHON SOURCE LINES 544-584

.. code-block:: default


    print("sample size: " + str(len(prediction_of_length)))
    print("<0.5 : " + str(counter_under_zero_five))
    print("<1 : " + str(counter_under_one))
    print("<2 : " + str(counter_under_two))
    print("<5 : " + str(counter_under_five))
    print("<10 : " + str(counter_under_ten))
    print(">10 : " + str(counter_upper_ten) + "\n")
    print(
        "sum : "
        + str(
            counter_under_zero_five
            + counter_under_one
            + counter_under_two
            + counter_under_five
            + counter_under_ten
            + counter_upper_ten
        )
    )

    print("-------------------------------------------\n")
    print("<0.01 : " + str(rel_counter_under_one))
    print("<0.02 : " + str(rel_counter_under_two))
    print("<0.05 : " + str(rel_counter_under_five))
    print("<0.1 : " + str(rel_counter_under_ten))
    print("<0.2 : " + str(rel_counter_under_twenty))
    print(">0.2 : " + str(rel_counter_upper_twenty))
    print(
        "sum : "
        + str(
            rel_counter_under_one
            + rel_counter_under_two
            + rel_counter_under_five
            + rel_counter_under_ten
            + rel_counter_under_twenty
            + rel_counter_upper_twenty
        )
    )
    print("average is : " + str(average_relative_gap))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    sample size: 8
    <0.5 : 0
    <1 : 0
    <2 : 0
    <5 : 0
    <10 : 2
    >10 : 6

    sum : 8
    -------------------------------------------

    <0.01 : 0
    <0.02 : 0
    <0.05 : 5
    <0.1 : 1
    <0.2 : 2
    >0.2 : 0
    sum : 8
    average is : 0.06029582550901666




.. GENERATED FROM PYTHON SOURCE LINES 585-588

Release AEDT
------------
Release AEDT.

.. GENERATED FROM PYTHON SOURCE LINES 588-590

.. code-block:: default


    hfss.release_desktop()




.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    True




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 10 minutes  9.421 seconds)


.. _sphx_glr_download_examples_02-HFSS_Machine_learning_applied_to_Patch.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: Machine_learning_applied_to_Patch.py <Machine_learning_applied_to_Patch.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: Machine_learning_applied_to_Patch.ipynb <Machine_learning_applied_to_Patch.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
