# -*- coding: utf-8 -*-
#
# Copyright (C) 2021 - 2024 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# from collections import OrderedDict
import json

# import math
import os
import shutil

import pandas as pd

from pyaedt.aedt_logger import pyaedt_logger as logger

# from pyaedt.application.Variables import decompose_variable_value
# from pyaedt.generic.constants import AEDT_UNITS
from pyaedt.generic.constants import unit_converter

# from pyaedt.generic.general_methods import conversion_function
from pyaedt.generic.general_methods import check_and_download_folder
from pyaedt.generic.general_methods import is_ironpython
from pyaedt.generic.general_methods import open_file
from pyaedt.generic.general_methods import pyaedt_function_handler

# from pyaedt.generic.plot import is_notebook
# from pyaedt.generic.plot import plot_2d_chart
# from pyaedt.generic.plot import plot_3d_chart
# from pyaedt.generic.plot import plot_contour
# from pyaedt.generic.plot import plot_polar_chart
from pyaedt.generic.settings import settings

# from pyaedt.generic.plot import ModelPlotter
# from pyaedt.generic.plot import get_structured_mesh


# import sys

np = None
pv = None
if not is_ironpython:
    try:
        import numpy as np
    except ImportError:  # pragma: no cover
        np = None
    try:
        import pyvista as pv
    except ImportError:  # pragma: no cover
        pv = None


class MonostaticRCSData(object):
    """Provides monostatic radar cross-section (RCS) data.

    Read monostatic RCS metadata in a JSON file generated by :func:`MonostaticRCSExporter` and return the
    Python interface to plot and analyze the RCS data.

    Parameters
    ----------
    input_file : str
        Metadata information in a JSON file.

    Examples
    --------

    >>> import pyaedt
    >>> from pyaedt.generic.rcs_visualization import MonostaticRCSData
    >>> app = pyaedt.Hfss(version="2023.2", design="Antenna")
    >>> data = app.get_rcs_data()
    >>> metadata_file = data.metadata_file
    >>> app.release_desktop()
    >>> rcs_data = MonostaticRCSData(input_file=metadata_file)
    """

    def __init__(self, input_file):

        # Public
        self.output_dir = os.path.dirname(input_file)

        if not os.path.isfile(input_file):  # pragma: no cover
            raise Exception("JSON file does not exist.")

        # Private
        self.__logger = logger
        self.__input_file = input_file
        self.__raw_data = {}
        self.__freq_index = 0
        self.__model_units = "meter"

        self.__element_info = {}
        self.__frequencies = []

        self.__model_info = {}
        self.__component_objects = None

        with open_file(input_file) as f:
            self.__metadata = json.load(f)

        if not self.metadata:  # pragma: no cover
            raise Exception("Metadata could not be loaded..")

        self.__monostatic_file = os.path.join(self.output_dir, self.metadata["monostatic_file"])

        if not os.path.isfile(monostatic_file):  # pragma: no cover
            raise Exception("Monostatic file invalid.")

        # Load farfield data
        is_rcs_loaded = self.__init_rcs()

        if not is_rcs_loaded:  # pragma: no cover
            raise Exception("RCS information can not be loaded.")

        # Update active frequency if passed in the initialization
        if frequency and frequency in self.frequencies:
            freq_index = self.frequencies.index(frequency)
            self.frequency = self.frequencies[freq_index]
        else:
            self.frequency = self.frequencies[0]

    @property
    def metadata(self):
        """Antenna metadata."""
        return self.__metadata

    @property
    def input_file(self):
        """Input file."""
        return self.__input_file

    @property
    def farfield_data(self):
        """Farfield data."""
        return self.combine_farfield(self.theta_scan, self.phi_scan)

    @property
    def element_info(self):
        """File information."""
        return self.__element_info

    @property
    def frequencies(self):
        """Available frequencies."""
        return self.__frequencies

    @property
    def all_element_names(self):
        """Available port names."""
        return self.__all_element_names

    @property
    def weight(self):
        """Weight."""
        return self.__weight

    @property
    def frequency(self):
        """Active frequency."""
        return self._frequency

    @frequency.setter
    def frequency(self, val):
        if isinstance(val, str):
            frequency, units = decompose_variable_value(val)
            unit_converter(frequency, "Freq", units, "Hz")
            val = frequency
        if val in self.frequencies:
            self._frequency = val
            self.__freq_index = self.frequencies.index(val)
        else:  # pragma: no cover
            self.__logger.error("Frequency not available.")

    @pyaedt_function_handler()
    def plot_cut(
        self,
        quantity="RealizedGain",
        primary_sweep="phi",
        secondary_sweep_value=0,
        phi=0,
        theta=0,
        title="Far Field Cut",
        quantity_format="dB10",
        output_file=None,
        show=True,
        is_polar=False,
        show_legend=True,
    ):
        """Create a 2D plot of a specified quantity in Matplotlib.

        Parameters
        ----------
        quantity : str, optional
            Quantity to plot. The default is ``"RealizedGain"``.
            Available quantities are: ``"RealizedGain"``, ``"RealizedGain_Theta"``, ``"RealizedGain_Phi"``,
            ``"rETotal"``, ``"rETheta"``, and ``"rEPhi"``.
        primary_sweep : str, optional.
            X-axis variable. The default is ``"phi"``. Options are ``"phi"`` and ``"theta"``.
        secondary_sweep_value : float, list, string, optional
            List of cuts on the secondary sweep to plot. The default is ``0``. Options are
            `"all"`, a single value float, or a list of float values.
        phi : float, int, optional
            Phi scan angle in degrees. The default is ``0``.
        theta : float, int, optional
            Theta scan angle in degrees. The default is ``0``.
        title : str, optional
            Plot title. The default is ``"RectangularPlot"``.
        quantity_format : str, optional
            Conversion data function.
            Available functions are: ``"abs"``, ``"ang"``, ``"dB10"``, ``"dB20"``, ``"deg"``, ``"imag"``, ``"norm"``,
            and ``"real"``.
        output_file : str, optional
            Full path for the image file. The default is ``None``, in which case an image in not exported.
        show : bool, optional
            Whether to show the plot. The default is ``True``.
            If ``False``, the Matplotlib instance of the plot is shown.
        is_polar : bool, optional
            Whether this plot is a polar plot. The default is ``True``.
        show_legend : bool, optional
            Whether to display the legend or not. The default is ``True``.

        Returns
        -------
        :class:`matplotlib.pyplot.Figure`
            Matplotlib figure object.
            If ``show=True``, a Matplotlib figure instance of the plot is returned.
            If ``show=False``, the plotted curve is returned.

        Examples
        --------
        >>> import pyaedt
        >>> app = pyaedt.Hfss(version="2023.2", design="Antenna")
        >>> setup_name = "Setup1 : LastAdaptive"
        >>> frequencies = [77e9]
        >>> sphere = "3D"
        >>> data = app.get_antenna_data(frequencies,setup_name,sphere)
        >>> data.plot_cut(theta=20)
        """

        data = self.combine_farfield(phi, theta)
        if quantity not in data:  # pragma: no cover
            raise Exception("Far field quantity not available.")

        data_to_plot = data[quantity]

        curves = []
        if primary_sweep.lower() == "phi":
            x_key, y_key = "Phi", "Theta"
            temp = data_to_plot
        else:
            y_key, x_key = "Phi", "Theta"
            temp = data_to_plot.T
        x = data[x_key]
        if is_polar:
            x = [i * 2 * math.pi / 360 for i in x]
        if secondary_sweep_value == "all":
            for el in data[y_key]:
                idx = self.__find_nearest(data[y_key], el)
                y = temp[idx]
                y = conversion_function(y, quantity_format)
                if not isinstance(y, np.ndarray):  # pragma: no cover
                    raise Exception("Format of quantity is wrong.")
                curves.append([x, y, "{}={}".format(y_key, el)])
        elif isinstance(secondary_sweep_value, list):
            list_inserted = []
            for el in secondary_sweep_value:
                theta_idx = self.__find_nearest(data[y_key], el)
                if theta_idx not in list_inserted:
                    y = temp[theta_idx]
                    y = conversion_function(y, quantity_format)
                    if not isinstance(y, np.ndarray):  # pragma: no cover
                        raise Exception("Format of quantity is wrong.")
                    curves.append([x, y, "{}={}".format(y_key, el)])
                    list_inserted.append(theta_idx)
        else:
            theta_idx = self.__find_nearest(data[y_key], secondary_sweep_value)
            y = temp[theta_idx]
            y = conversion_function(y, quantity_format)
            if not isinstance(y, np.ndarray):  # pragma: no cover
                raise Exception("Wrong format quantity.")
            curves.append([x, y, "{}={}".format(y_key, data[y_key][theta_idx])])

        if is_polar:
            return plot_polar_chart(
                curves,
                xlabel=x_key,
                ylabel=quantity,
                title=title,
                snapshot_path=output_file,
                show_legend=show_legend,
                show=show,
            )
        else:
            return plot_2d_chart(
                curves,
                xlabel=x_key,
                ylabel=quantity,
                title=title,
                snapshot_path=output_file,
                show_legend=show_legend,
                show=show,
            )

    @pyaedt_function_handler()
    def __init_rcs(self):
        """Load monostatic radar cross-section data.

        Returns
        -------
        bool
            ``True`` when successful, ``False`` when failed.
        """

        file_extension = os.path.splitext(self.__monostatic_file)[1]
        if file_extension == "h5":
            try:
                self.__raw_data = df.read_hdf(self.__monostatic_file, key="df", mode="w", format="table")
            except ImportError as e:  # pragma: no cover
                self.__app.logger.error(f"PyTables is not installed: {e}")
                return False
        else:
            self.__raw_data = pd.read_pickle(self.__monostatic_file)
        return True

    @pyaedt_function_handler()
    def __get_geometry(self, off_screen=False):
        """Get 3D meshes."""
        model_info = self.metadata["model_info"]
        obj_meshes = []
        if self.__is_array:
            non_array_geometry = model_info.copy()
            components_info = self.__component_objects
            array_dimension = self.__array_dimension
            first_value = next(iter(model_info.values()))
            sf = AEDT_UNITS["Length"][first_value[3]]
            self.__model_units = first_value[3]
            cell_info = self.__cell_position

            for cell_row in cell_info:
                for cell_col in cell_row:
                    # Initialize an empty mesh for this component
                    model_pv = ModelPlotter()
                    model_pv.off_screen = off_screen
                    component_name = cell_col[0]
                    component_info = components_info[component_name]
                    rotation = cell_col[2]
                    for component_obj in component_info[1:]:
                        if component_obj in model_info:
                            if component_obj in non_array_geometry:
                                del non_array_geometry[component_obj]

                            cad_path = os.path.join(self.output_dir, model_info[component_obj][0])
                            if os.path.exists(cad_path):
                                model_pv.add_object(
                                    cad_path,
                                    model_info[component_obj][1],
                                    model_info[component_obj][2],
                                    model_info[component_obj][3],
                                )

                    model_pv.generate_geometry_mesh()
                    comp_meshes = []
                    row, col = cell_col[3]

                    # Perpendicular lattice vector
                    if self.__lattice_vector[0] != 0:
                        pos_x = (row - 1) * array_dimension[2] - array_dimension[0] / 2 + array_dimension[2] / 2
                        pos_y = (col - 1) * array_dimension[3] - array_dimension[1] / 2 + array_dimension[3] / 2
                    else:
                        pos_y = (row - 1) * array_dimension[2] - array_dimension[0] / 2 + array_dimension[2] / 2
                        pos_x = (col - 1) * array_dimension[3] - array_dimension[1] / 2 + array_dimension[3] / 2

                    for obj in model_pv.objects:
                        mesh = obj._cached_polydata
                        translated_mesh = mesh.copy()
                        color_cad = [i / 255 for i in obj.color]

                        translated_mesh.translate(
                            [-component_info[0][0] / sf, -component_info[0][1] / sf, -component_info[0][2] / sf],
                            inplace=True,
                        )

                        if rotation != 0:
                            translated_mesh.rotate_z(rotation, inplace=True)

                        # Translate the mesh to its position
                        translated_mesh.translate([pos_x / sf, pos_y / sf, component_info[0][2] / sf], inplace=True)

                        comp_meshes.append([translated_mesh, color_cad, obj.opacity])

                    obj_meshes.append(comp_meshes)
                    model_pv.close()

            obj_meshes = [item for sublist in obj_meshes for item in sublist]
        else:
            non_array_geometry = model_info

        if non_array_geometry:  # pragma: no cover
            model_pv = ModelPlotter()
            first_value = next(iter(non_array_geometry.values()))
            sf = AEDT_UNITS["Length"][first_value[3]]
            self.__model_units = first_value[3]
            model_pv.off_screen = off_screen
            for object_in in non_array_geometry.values():
                cad_path = os.path.join(self.output_dir, object_in[0])
                if os.path.exists(cad_path):
                    model_pv.add_object(
                        cad_path,
                        object_in[1],
                        object_in[2],
                        object_in[3],
                    )
                else:
                    self.logger.warning(f"{cad_path} does not exist.")
                    return False
            self.__model_units = first_value[3]
            model_pv.generate_geometry_mesh()
            i = 0
            for obj in model_pv.objects:
                mesh = obj._cached_polydata
                translated_mesh = mesh.copy()
                color_cad = [i / 255 for i in obj.color]

                if len(obj_meshes) > i:
                    obj_meshes[i][0] += translated_mesh
                else:
                    obj_meshes.append([translated_mesh, color_cad, obj.opacity])
                i += 1
            model_pv.close()

        return obj_meshes


class MonostaticRCSExporter:
    """Class to enable export of radar cross-section (RCS) data from HFSS.

    An instance of this class is returned from the
    :meth:`pyaedt.Hfss.get_monostatic_rcs` method. This class creates a
    ``metadata_file`` that can be passed as argument to instantiate an instance of the
    :class:`pyaedt.generic.rcs_visualization.MonostaticRCSData` class for subsequent analysis and postprocessing.

    Note that this class is derived from the :class:`MonostaticRCSData` class and can be used directly for
    RCS postprocessing, but it remains as a property of the :class:`pyaedt.Hfss` application.

    Parameters
    ----------
    app : :class:`pyaedt.Hfss`
        HFSS application instance.
    setup_name : str
        Name of the setup. Make sure to build a setup string in the form of ``"SetupName : SetupSweep"``.
    frequencies : list
        Frequency list to export. Specify either a list of strings with units or a list of floats in Hertz units.
        For example, ``["9GHz", 9e9]``.
    variations : dict, optional
        Dictionary of all families including the primary sweep. The default value is ``None``.
    overwrite : bool, optional
        Whether to overwrite the existing far field solution data. The default is ``True``.

    Examples
    --------
    >>> import pyaedt
    >>> app = pyaedt.Hfss(version="2023.2", design="Antenna")
    >>> setup_name = "Setup1 : LastAdaptive"
    >>> frequencies = [77e9]
    >>> sphere = "3D"
    >>> data = app.get_monostatic_rcs(frequencies,setup_name,sphere)
    >>> data.plot_3d(quantity_format="dB10")
    """

    def __init__(
        self,
        app,
        setup_name,
        frequencies,
        variations=None,
        overwrite=True,
    ):
        # Public
        self.setup_name = setup_name
        self.variation_name = ""
        self.export_format = "pkl"

        if not variations:
            variations = app.available_variations.nominal_w_values_dict_w_dependent
        else:
            # Set variation to Nominal
            for var_name, var_value in variations.items():
                app[var_name] = var_value

        self.variations = variations
        self.overwrite = overwrite

        if not isinstance(frequencies, list):
            self.frequencies = [frequencies]
        else:
            self.frequencies = frequencies

        # Private
        self.__app = app
        self.__model_info = {}
        self.__rcs_data = None
        self.__metadata_file = ""

        self.__theta_column_name = "ComplexMonostaticRCSTheta"
        self.__phi_column_name = "ComplexMonostaticRCSPhi"

    @property
    def model_info(self):
        """List of models."""
        return self.__model_info

    @property
    def rcs_data(self):
        """Monostatic RCS data."""
        return self.__rcs_data

    @property
    def metadata_file(self):
        """Metadata file."""
        return self.__metadata_file

    @property
    def theta_column_name(self):
        """Theta column name."""
        return self.__theta_column_name

    @theta_column_name.setter
    def theta_column_name(self, value):
        """Theta column name."""
        self.__theta_column_name = value

    @property
    def phi_column_name(self):
        """Phi column name."""
        return self.__phi_column_name

    @phi_column_name.setter
    def phi_column_name(self, value):
        """Phi column name."""
        self.__phi_column_name = value

    @pyaedt_function_handler()
    def get_monostatic_rcs(self):
        """Get RCS solution data."""

        variations = self.variations
        variations["IWaveTheta"] = ["All"]
        variations["IWavePhi"] = ["All"]
        variations["Freq"] = self.frequencies

        solution_data = self.__app.post.get_solution_data(
            ["ComplexMonostaticRCSTheta", "ComplexMonostaticRCSPhi"],
            variations=variations,
            setup_sweep_name=self.setup_name,
            report_category="Monostatic RCS",
        )
        solution_data.enable_pandas_output = True
        return solution_data

    @pyaedt_function_handler()
    def export_rcs(self, name="monostatic_data", metadata_name="pyaedt_rcs_metadata", output_format="pkl"):
        """Export RCS solution data."""

        # Output directory
        solution_setup_name = self.setup_name.replace(":", "_").replace(" ", "")
        full_setup = "{}".format(solution_setup_name)
        export_path = "{}/{}/".format(self.__app.working_directory, full_setup)
        local_path = "{}/{}/".format(settings.remote_rpc_session_temp_folder, full_setup)
        export_path = os.path.abspath(check_and_download_folder(local_path, export_path))

        # Variation name
        var = []
        if self.variations:
            for k, v in self.variations.items():
                var.append("{}='{}'".format(k, v))
            variation = " ".join(var)
        else:
            variation = self.__app.odesign.GetNominalVariation()

        if not self.variation_name:
            self.variation_name = variation

        file_name = f"{name}.{output_format}"
        full_path = os.path.join(export_path, file_name)
        pyaedt_metadata_file = os.path.join(export_path, f"{metadata_name}_{self.variation_name}.json")

        # Create directory or check if files already exist
        if settings.remote_rpc_session:  # pragma: no cover
            settings.remote_rpc_session.filemanager.makedirs(export_path)
            file_exists = settings.remote_rpc_session.filemanager.pathexists(pyaedt_metadata_file)
        elif not os.path.exists(export_path):
            os.makedirs(export_path)
            file_exists = False
        else:
            file_exists = os.path.exists(pyaedt_metadata_file)

        # Export monostatic RCS
        if self.overwrite or not file_exists:

            data = self.get_monostatic_rcs()

            if not data or data.number_of_variations != 1:  # pragma: no cover
                self.__app.logger.error("Data can not be obtained.")
                return False

            df = data.full_matrix_real_imag[0] + complex(0, 1) * data.full_matrix_real_imag[1]
            df.index.names = [*data.variations[0].keys(), *data.intrinsics.keys()]
            df = df.reset_index(level=[*data.variations[0].keys()], drop=True)
            df = unit_converter(
                df, unit_system="Length", input_units=data.units_data["ComplexMonostaticRCSPhi"], output_units="meter"
            )

            df.rename(
                columns={
                    "ComplexMonostaticRCSTheta": self.theta_column_name,
                    "ComplexMonostaticRCSPhi": self.phi_column_name,
                }
            )

            if output_format == "h5":
                try:
                    df.to_hdf(full_path, key="df", mode="w", format="table")
                except ImportError as e:  # pragma: no cover
                    self.__app.logger.error(f"PyTables is not installed: {e}")
                    return False
            else:
                df.to_pickle(full_path)

            if not os.path.isfile(full_path):  # pragma: no cover
                self.__app.logger.error("RCS data file not exported.")
                return False
        else:
            self.__app.logger.info("Using existing RCS file.")

        # Export geometry
        if os.path.isfile(full_path):
            geometry_path = os.path.join(export_path, "geometry")
            if not os.path.exists(geometry_path):
                os.mkdir(geometry_path)
            obj_list = self.__create_geometries(geometry_path)
            if obj_list:
                self.__model_info["object_list"] = obj_list

        items = {
            "variation": self.variation_name,
            "monostatic_file": file_name,
            "model_units": self.__app.modeler.model_units,
            "model_info": [],
        }

        if self.model_info and "object_list" in self.model_info:
            items["model_info"] = self.model_info["object_list"]

        with open_file(pyaedt_metadata_file, "w") as f:
            json.dump(items, f, indent=2)
        if not pyaedt_metadata_file:  # pragma: no cover
            return False

        self.__metadata_file = pyaedt_metadata_file
        self.__rcs_data = FfdSolutionData(pyaedt_metadata_file)
        return pyaedt_metadata_file

    @pyaedt_function_handler()
    def __create_geometries(self, export_path):
        """Export the geometry in OBJ format."""
        self.__app.logger.info("Exporting geometry...")
        model_pv = self.__app.post.get_model_plotter_geometries(plot_air_objects=False)
        obj_list = {}
        for obj in model_pv.objects:
            object_name = os.path.basename(obj.path)
            name = os.path.splitext(object_name)[0]
            original_path = os.path.dirname(obj.path)
            new_path = os.path.join(os.path.abspath(export_path), object_name)

            if not os.path.exists(new_path):
                new_path = shutil.move(obj.path, export_path)
            if os.path.exists(os.path.join(original_path, name + ".mtl")):  # pragma: no cover
                os.remove(os.path.join(original_path, name + ".mtl"))
            obj_list[obj.name] = [
                os.path.join(os.path.basename(export_path), object_name),
                obj.color,
                obj.opacity,
                obj.units,
            ]
        return obj_list
